<!DOCTYPE html>
<!--
    Massively by HTML5 UP
    html5up.net | @ajlkn
    Hakyll integration by Sebastian Graf
    Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

    <title>fixpt - All About Strictness Analysis (part 2)</title>

    <link rel="apple-touch-icon" sizes="180x180" href="../assets/icon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../assets/icon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../assets/icon/favicon-16x16.png">
    <link rel="manifest" href="../assets/icon/manifest.json">
    <link rel="mask-icon" href="../assets/icon/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href="../assets/icon/favicon.ico">
    <meta name="msapplication-config" content="/assets/icon/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">

    <!-- CSS -->
    <link rel="stylesheet" href="../assets/css/main.css" />
    <link rel="stylesheet" href="../assets/css/pygments.css" />
    <noscript>
        <link rel="stylesheet" href="../assets/css/noscript.css" />
    </noscript>
</head>

<body>
    <div id="wrapper" class="bg">
        <header id="header">
            <a href="../" class="logo">fixpt</a>
        </header>

        <nav id="nav">
            <ul class="links">
                <li class="active">
                    <a href="../">Blog</a>
                </li>
                <li class>
                    <a href="../about.html">About</a>
                </li>
            </ul>

            <ul class="icons">
                <li>
                    <a href="https://reddit.com/user/sgraf812" class="icon fa-reddit" rel="nofollow">
                        <span class="label">Reddit</span>
                    </a>
                </li>
                <li>
                    <a href="https://github.com/sgraf812" class="icon fa-github" rel="nofollow">
                        <span class="label">GitHub</span>
                    </a>
                </li>
                <li>
                    <a href="https://twitter.com/sgraf1337" class="icon fa-twitter" rel="nofollow">
                        <span class="label">Twitter</span>
                    </a>
                </li>
            </ul>
        </nav>

        <div id="main">
            <section class="post">
  <header class="major">
    <span class="date">December 30, 2018</span>
    <h1>All About Strictness Analysis (part 2)</h1>
  </header>
  <p>Welcome back! At the end of <a href="../blog/2017-12-04-strictness-analysis-part-1.html">part 1</a> from December 4<sup id="a1"><a href="#f1">1</a></sup>, I made a promise to implement a strictness analysis à la GHC with you.</p>
<p>Why would this be useful? In the last post, I argued that a rough understanding of how strictness analysis works helps to debug and identify the actual causes of missed unboxing opportunities and fix them with minimal effort.</p>
<p>So here it is, enjoy!</p>
<!--more-->
<hr />
<p>Since this is a literate markdown file, we need to get the boring preamble out of the way.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE LambdaCase #-}</span>
<span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>

<span class="kw">module</span> <span class="dt">Strictness</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (const)
<span class="kw">import </span><span class="dt">Algebra.Lattice</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)
<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import qualified</span> <span class="dt">Data.Map.Merge.Strict</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span> (fromMaybe, mapMaybe)
<span class="kw">import </span><span class="dt">Debug.Trace</span></code></pre></div>
<h2 id="syntax">Syntax</h2>
<p>Compared to GHC’s Core IR, we will have a simpler, untyped core calculus with <code>let</code> bindings and if/then/else (instead of full-blown case expressions).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">Name</span>
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Name</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Let</span> <span class="dt">Bind</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">If</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span> <span class="co">-- We assume names are unique!</span>

<span class="kw">data</span> <span class="dt">Bind</span>
  <span class="fu">=</span> <span class="dt">NonRec</span> (<span class="dt">Name</span>, <span class="dt">Expr</span>)
  <span class="fu">|</span> <span class="dt">Rec</span> [(<span class="dt">Name</span>, <span class="dt">Expr</span>)]
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>Like in GHC, a program is just a list of top-level bindings. Also note that we allow recursive bindings, which means the analysis will need to do <em>fixed-point iteration</em> to reach a sound approximation of program semantics.</p>
<p>Next, we’ll define the <a href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice</a> that will carry analysis information. Specifically, we will denote an expression by its <em>strictness type</em>.</p>
<p>By the way, this blog post is so long because I tried to fit everything in one literate Haskell file. Morally, this post should be split in two (or even three) parts: One discussing lattice ingredients and the other discussing how to actually implement the analysis, just in case you felt overwhelmed when looking at the scroll bar after scrolling the first time :). I’ll remind you to take a break later on.</p>
<h2 id="lattice">Lattice</h2>
<p>For brevity, we will not include strictness on tuple components (resp. record fields), because that would blow up this blog post too much. But know that this approach extends straight-forwardly to records.</p>
<h3 id="strictness-signatures">Strictness signatures</h3>
<p>Without nested strictness on product types, is there even anything useful to analyse for? Yes, there is! We can still record if a variable was evaluated at all. There’s <code>const</code>, for example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">const<span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a
const a b <span class="fu">=</span> a</code></pre></div>
<p><code>const</code> is strict in its first argument and lazy in its second. That’s easy to see by evaluating <code>const undefined 5</code> and <code>const 5 undefined</code>. So, in the language of GHC’s demand signatures, we want to summarise <code>const</code> by <code>&lt;S,_&gt;&lt;L,_&gt;</code> (usage demands elided). GHC will use this strictness signature at every call site of <code>const</code> to approximate the strictness behavior of <code>const</code> without having to repeatedly analyse its right-hand side during analysis.</p>
<h3 id="call-demands">Call demands</h3>
<p>Fair enough, but what about a function like <code>twice</code>?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">twice ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
twice f x <span class="fu">=</span> f (f x)</code></pre></div>
<p>Since we don’t know anything about what strictness <code>f</code> puts on its argument, we would summarise <code>twice</code> by the same signature as <code>const</code>. But we really want a call like <code>twice (\x -&gt; x + n) m</code> to be strict in <code>n</code>! Just knowing that we are <em>head</em>-strict in the lambda argument doesn’t cut it: Evaluation will stop immediately since it’s already in weak-head normal form. On the other hand, we can’t just interpret <code>S</code> as ‘strict on the return value’ (what does that even mean?) to unleash strictness on <code>n</code> within the lambda body. Since <code>const</code> has the same signature, we would also mark <code>n</code> strict in a call like <code>const (\x -&gt; x + m) 5</code>, which is incorrect: <code>const (\x -&gt; undefined) 5 `seq` 42 == 42</code>.</p>
<p>There’s an unspoken assumption here: Strictness properties of some language construct are always relative to an incoming <em>evaluation demand</em>, which is head-strictness (the demand <code>seq</code> puts on its first argument) unless stated otherwise. E.g., under the assumption of head-strictness, a call like <code>const a b</code> is head-strict on <code>a</code> and lazy in <code>b</code>.</p>
<p>Note that <code>twice</code> differs from <code>const</code> in that it puts the <em>result</em> of applying <code>f</code> to one argument under head-strictness. In GHC’s strictness language, this corresponds to a <em>call demand</em> of <code>S(S)</code>. This is a strictly stronger demand than <code>S</code>, the demand <code>const</code> puts on its first argument.</p>
<p>This has an important effect on our earlier <code>twice (\x -&gt; x + n) m</code> example. Knowing that the lambda expression is put under strictness demand <code>S(S)</code>, it is suddenly possible for the analysis to look inside the lambda abstraction, paying with the outer call component to discharge the remaining <code>S</code> demand on the lambda body. In this way, the analysis detects that the whole expression is strict in <code>n</code>.</p>
<p>At the same time, analysing <code>const (\x -&gt; undefined) 5</code> assuming head-strictness will only unleash a non-call demand <code>S</code> on the lambda, which is not enough to meaningfully analyse its body under any other strictness than <code>L</code>. This corresponds to our intuition that, relative to a single evaluation (to head normal form) of our expression, the lambda body may or may not be evaluated.</p>
<h3 id="free-variables">Free variables</h3>
<p>You may have noticed that we didn’t really define yet what it means for a variable to be strict in some expression in which it occurs free.</p>
<p>Traditionally, a function <code>f</code> is strict in (one of) its parameter if it preserves nontermination, i.e. <code>f undefined = undefined</code>. There’s no way for the function to decide if its argument will blow up when evaluated other than actually evaluating it, so it’s equivalent to say that if <code>f</code> is strict, then (either <code>f = const undefined</code> or) it evaluates its argument on every possible execution path.</p>
<p>How can we extend this to our intuitive notion of strictness in a variable that occurs free in some expression? We can just capture that free variable with a lambda and apply our original definition. So, when we talk about the strictness of <code>n</code> as it demanded in <code>twice (\x -&gt; x + n) m</code>, we are actually talking about strictness properties of the function <code>\n -&gt; twice (\x -&gt; x + n) m</code>.</p>
<p>Our analysis will track free variables in an extra <em>environment</em>, mapping <code>Name</code>s to the strictness demand they are put under.</p>
<p>Now might be a good time to take a short break (think part 2½). Or just keep reading while the above discussion is still fresh in your mind.</p>
<h3 id="putting-the-lattice-together">Putting the lattice together</h3>
<p>Alright, so now we have everything in place to denote Haskell expressions in terms of their strictness properties.</p>
<p>As discussed above, expressions, most prominently variables, can be put under a certain <code>Strictness</code>, relative to an evaluation demand on their surrounding expression:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Captures lower bounds on evaluation cardinality of some expression.</span>
<span class="co">-- E.g.: Is this expression evaluated at least once? If so, what is the</span>
<span class="co">-- maximum number of arguments it was surely applied to?</span>
<span class="kw">data</span> <span class="dt">Strictness</span>
  <span class="fu">=</span> <span class="dt">Lazy</span>        <span class="co">-- ^ Evaluated lazily (possibly not evaluated at all)</span>
  <span class="fu">|</span> <span class="dt">Strict</span> <span class="dt">Int</span>  <span class="co">-- ^ Evaluated strictly (at least once), called with n args</span>
  <span class="fu">|</span> <span class="dt">HyperStrict</span> <span class="co">-- ^ Fully evaluated, a call with maximum arity</span>
  <span class="kw">deriving</span> <span class="dt">Eq</span>

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Strictness</span> <span class="kw">where</span>
  show <span class="dt">Lazy</span> <span class="fu">=</span> <span class="st">&quot;L&quot;</span>
  show (<span class="dt">Strict</span> <span class="dv">0</span>) <span class="fu">=</span> <span class="st">&quot;S&quot;</span>
  show (<span class="dt">Strict</span> n) <span class="fu">=</span> <span class="st">&quot;S(&quot;</span> <span class="fu">++</span> show (<span class="dt">Strict</span> (n<span class="fu">-</span><span class="dv">1</span>)) <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
  show <span class="dt">HyperStrict</span> <span class="fu">=</span> <span class="st">&quot;B&quot;</span></code></pre></div>
<p>The <code>Show</code> instance tries to adhere to GHC’s syntax. You can see how call demands <code>S(_)</code> and regular strictness <code>S</code> could be elegantly unified in this formulation. I snuck in another constructor, <code>HyperStrict</code>. You can think of it as the strongest strictness possible. In our case, that corresponds to a call with infinite arity.</p>
<p>Earlier, we were informally talking about how <code>S</code> is a <em>stronger</em> demand than <code>L</code>. We can capture that meaning by providing an instance of <code>SemiJoinLattice</code>, which consists of defining a <em>least upper bound</em> operator <code>\/</code> (also goes by <em>join</em> or <em>supremum</em>):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">JoinSemiLattice</span> <span class="dt">Strictness</span> <span class="kw">where</span>
  <span class="dt">Lazy</span> \<span class="fu">/</span> _ <span class="fu">=</span> <span class="dt">Lazy</span>
  _ \<span class="fu">/</span> <span class="dt">Lazy</span> <span class="fu">=</span> <span class="dt">Lazy</span>
  <span class="dt">HyperStrict</span> \<span class="fu">/</span> s <span class="fu">=</span> s
  s \<span class="fu">/</span> <span class="dt">HyperStrict</span> <span class="fu">=</span> s
  <span class="dt">Strict</span> n \<span class="fu">/</span> <span class="dt">Strict</span> m <span class="fu">=</span> <span class="dt">Strict</span> (min n m)</code></pre></div>
<p>On a total <code>Ord</code> like <code>Strictness</code>, this is just a fancy name for <code>max</code>. “Hold on,”, I hear you complain, “I thought <code>HyperStrict</code> was the greatest element?! This is all backwards!”. <details> <summary>Answer with a quick detour on denotational semantics and static program analysis</summary></p>
<p>Well, it’s customary in denotational semantics to assume that the bottom element of the abstract lattice corresponds to nontermination. So much, that Haskellers typically use the two terms ‘bottom’ and ‘nontermination’ interchangeably.</p>
<p>Now think of static program analysis, where every program point that evaluates some expression will put semantic constraints on its denotation. A conservative estimate of program semantics must be an upper bound to the all constraints at that program point over every possible program path.</p>
<p>Consider the contrived example <code>if b then f 1 else f `seq` 42</code>; each occurrence of <code>f</code> generates a semantic constraint on mutually exclusive code paths. While the first occurrence is a call with one argument, i.e. denoted by <code>Strict 1</code>, the second occurrence just puts <code>f</code> under a rather weak <code>Strict 0</code> (i.e. head-strict) constraint.</p>
<p>What is the conservative estimate to strive for here? It’s the join of <code>Strict 1</code> and <code>Strict 0</code>, so <code>Strict 0</code>! Generally speaking, as we discover more and more constraints <code>f</code> is put under, its denotation will climb up in the lattice. So, going up in the lattice means ‘more constrained’.</p>
<p>Note that there is also precedent of turning the lattice upside down and denoting the least constrained element by top. This view is adopted in the <a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">dragon book</a>, for example.</p>
<p></details></p>
<p>Clearly, the least (or, bottom) element of the lattice wrt. to the above join operator is <code>HyperStrict</code>. This justifies the following instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">BoundedJoinSemiLattice</span> <span class="dt">Strictness</span> <span class="kw">where</span>
  bottom <span class="fu">=</span> <span class="dt">HyperStrict</span></code></pre></div>
<p>There’s some more boilerplate ahead for the dual semilattice, defining the <em>greatest lower bound</em> or <em>meet</em> or <em>infimum</em> operator and an associated top element:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MeetSemiLattice</span> <span class="dt">Strictness</span> <span class="kw">where</span>
  <span class="dt">HyperStrict</span> <span class="fu">/</span>\ _ <span class="fu">=</span> <span class="dt">HyperStrict</span>
  _ <span class="fu">/</span>\ <span class="dt">HyperStrict</span> <span class="fu">=</span> <span class="dt">HyperStrict</span>
  <span class="dt">Lazy</span> <span class="fu">/</span>\ s <span class="fu">=</span> s
  s <span class="fu">/</span>\ <span class="dt">Lazy</span> <span class="fu">=</span> s
  <span class="dt">Strict</span> n <span class="fu">/</span>\ <span class="dt">Strict</span> m <span class="fu">=</span> <span class="dt">Strict</span> (max n m)

<span class="kw">instance</span> <span class="dt">BoundedMeetSemiLattice</span> <span class="dt">Strictness</span> <span class="kw">where</span>
  top <span class="fu">=</span> <span class="dt">Lazy</span></code></pre></div>
<p>By the way, the syntactic resemblence to boolean operators is no accident: In fact, the boolean algebra itself <a href="https://en.wikipedia.org/wiki/Boolean_algebra_(structure)">is a very special kind of lattice</a>.</p>
<p>Where would this be useful? If you squint a little and call the meet operator ‘both’ (for now), you can denote sequential composition with this.</p>
<p>Consider <code>if b `seq` True then b 42 else 1</code>. What strictness does this place on <code>b</code>? Earlier, we used the join operator to combine strictness from the <code>then</code> and <code>else</code> branch, corresponding to <em>mutually exclusive</em> choices. That makes <code>Strict 1 \/ Lazy = Lazy</code> for this example (note that <code>b</code> wasn’t used at all in the <code>else</code> branch!). Now, there’s also an interesting condition to be analysed, which puts <code>b</code> under <code>Strict 0</code> strictness. The condition will certainly execute in the same evaluation as either branch. Thus, we can pick the <em>stronger demand</em> of either the condition or the join of the branches, which is <code>Strict 0 /\ Lazy = Strict 0</code>.</p>
<p>Great! That’s the bounded lattice for denoting variables. We can extend this denotation to expressions by means of an environment tracking the strictness demands on its free variables upon being put under a certain (i.e. head-strict) evaluation demand:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | A total map (a /function/) from @k@ to @v@ with useful</span>
<span class="co">-- lattice instances.</span>
<span class="kw">data</span> <span class="dt">TotalMap</span> k v
  <span class="fu">=</span> <span class="dt">TotalMap</span>
  {<span class="ot"> def ::</span> <span class="fu">!</span>v
  ,<span class="ot"> points ::</span> <span class="fu">!</span>(<span class="dt">Map</span> k v)
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="ot">lookupTM ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">TotalMap</span> k v <span class="ot">-&gt;</span> v
<span class="ot">insertTM ::</span> (<span class="dt">Ord</span> k, <span class="dt">Eq</span> v) <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">TotalMap</span> k v <span class="ot">-&gt;</span> <span class="dt">TotalMap</span> k v
<span class="ot">deleteTM ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">TotalMap</span> k v <span class="ot">-&gt;</span> <span class="dt">TotalMap</span> k v

<span class="kw">type</span> <span class="dt">StrEnv</span> <span class="fu">=</span> <span class="dt">TotalMap</span> <span class="dt">Name</span> <span class="dt">Strictness</span></code></pre></div>
<p>Such a <code>StrEnv</code> is just a total map from <code>Name</code>s to <code>Strictness</code>. We can just use its point-wise lattice instance and be done with it. <details> <summary>Boring implementations and lattice instances</summary></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">lookupTM n env <span class="fu">=</span>
  fromMaybe (def env) (Map.lookup n (points env))

insertTM n s env
  <span class="fu">|</span> s <span class="fu">==</span> def env <span class="fu">=</span> env { points <span class="fu">=</span> Map.delete n (points env) }
  <span class="fu">|</span> otherwise    <span class="fu">=</span> env { points <span class="fu">=</span> Map.insert n s (points env) }

deleteTM n env <span class="fu">=</span>
  env { points <span class="fu">=</span> Map.delete n (points env) }

<span class="ot">joinOrMeet ::</span> (<span class="dt">Eq</span> v, <span class="dt">Ord</span> k) <span class="ot">=&gt;</span> (v <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> v) <span class="ot">-&gt;</span> <span class="dt">TotalMap</span> k v <span class="ot">-&gt;</span> <span class="dt">TotalMap</span> k v <span class="ot">-&gt;</span> <span class="dt">TotalMap</span> k v
joinOrMeet (<span class="fu">/</span>\<span class="fu">/</span>) (<span class="dt">TotalMap</span> def1 ps1) (<span class="dt">TotalMap</span> def2 ps2) <span class="fu">=</span> <span class="dt">TotalMap</span> def ps
  <span class="kw">where</span>
    def <span class="fu">=</span> def1 <span class="fu">/</span>\<span class="fu">/</span> def2
    filterMaybe f a <span class="fu">=</span> a <span class="fu">&lt;$</span> guard (f a)
    mmc f <span class="fu">=</span> Map.mapMaybeMissing (\_ <span class="ot">-&gt;</span> filterMaybe (<span class="fu">/=</span> def) <span class="fu">.</span> f)
    zmmc f <span class="fu">=</span> Map.zipWithMaybeMatched (\_ a <span class="ot">-&gt;</span> filterMaybe (<span class="fu">/=</span> def) <span class="fu">.</span> f a)
    ps <span class="fu">=</span> Map.merge (mmc (<span class="fu">/</span>\<span class="fu">/</span> def2)) (mmc (def1 <span class="fu">/</span>\<span class="fu">/</span>)) (zmmc (<span class="fu">/</span>\<span class="fu">/</span>)) ps1 ps2

<span class="kw">instance</span> (<span class="dt">Ord</span> k, <span class="dt">Eq</span> v, <span class="dt">JoinSemiLattice</span> v) <span class="ot">=&gt;</span> <span class="dt">JoinSemiLattice</span> (<span class="dt">TotalMap</span> k v) <span class="kw">where</span>
  (\<span class="fu">/</span>) <span class="fu">=</span> joinOrMeet (\<span class="fu">/</span>)

<span class="kw">instance</span> (<span class="dt">Ord</span> k, <span class="dt">Eq</span> v, <span class="dt">BoundedJoinSemiLattice</span> v) <span class="ot">=&gt;</span> <span class="dt">BoundedJoinSemiLattice</span> (<span class="dt">TotalMap</span> k v) <span class="kw">where</span>
  bottom <span class="fu">=</span> <span class="dt">TotalMap</span> bottom Map.empty

<span class="kw">instance</span> (<span class="dt">Ord</span> k, <span class="dt">Eq</span> v, <span class="dt">MeetSemiLattice</span> v) <span class="ot">=&gt;</span> <span class="dt">MeetSemiLattice</span> (<span class="dt">TotalMap</span> k v) <span class="kw">where</span>
  (<span class="fu">/</span>\) <span class="fu">=</span> joinOrMeet (<span class="fu">/</span>\)

<span class="kw">instance</span> (<span class="dt">Ord</span> k, <span class="dt">Eq</span> v, <span class="dt">BoundedMeetSemiLattice</span> v) <span class="ot">=&gt;</span> <span class="dt">BoundedMeetSemiLattice</span> (<span class="dt">TotalMap</span> k v) <span class="kw">where</span>
  top <span class="fu">=</span> <span class="dt">TotalMap</span> top Map.empty</code></pre></div>
<p></details></p>
<p>This is enough vocabulary to analyse simple expressions. But, as discussed above, we need argument strictness to express how a function or lambda uses its arguments. So here we go:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ArgStr</span>
  <span class="fu">=</span> <span class="dt">BottomArgStr</span>
  <span class="fu">|</span> <span class="dt">TopArgStr</span>
  <span class="fu">|</span> <span class="dt">ConsArgStr</span> <span class="dt">Strictness</span> <span class="dt">ArgStr</span>
  <span class="kw">deriving</span> <span class="dt">Eq</span>

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">ArgStr</span> <span class="kw">where</span>
  show <span class="dt">BottomArgStr</span> <span class="fu">=</span> <span class="st">&quot;B,B..&quot;</span>
  show <span class="dt">TopArgStr</span> <span class="fu">=</span> <span class="st">&quot;L,L..&quot;</span>
  show (<span class="dt">ConsArgStr</span> s argStr) <span class="fu">=</span> show s <span class="fu">++</span> <span class="st">&quot;,&quot;</span> <span class="fu">++</span> show argStr

<span class="kw">instance</span> <span class="dt">JoinSemiLattice</span> <span class="dt">ArgStr</span> <span class="kw">where</span>
  <span class="dt">BottomArgStr</span> \<span class="fu">/</span> s <span class="fu">=</span> s
  s \<span class="fu">/</span> <span class="dt">BottomArgStr</span> <span class="fu">=</span> s
  <span class="dt">TopArgStr</span> \<span class="fu">/</span> _ <span class="fu">=</span> <span class="dt">TopArgStr</span>
  _ \<span class="fu">/</span> <span class="dt">TopArgStr</span> <span class="fu">=</span> <span class="dt">TopArgStr</span>
  (<span class="dt">ConsArgStr</span> s1 a1) \<span class="fu">/</span> (<span class="dt">ConsArgStr</span> s2 a2) <span class="fu">=</span> <span class="dt">ConsArgStr</span> (s1 \<span class="fu">/</span> s2) (a1 \<span class="fu">/</span> a2)

<span class="kw">instance</span> <span class="dt">BoundedJoinSemiLattice</span> <span class="dt">ArgStr</span> <span class="kw">where</span>
  bottom <span class="fu">=</span> <span class="dt">BottomArgStr</span>

<span class="co">-- | This instance doesn't make a lot of sense semantically,</span>
<span class="co">-- but it's the dual to the 'JoinSemiLattice' instance.</span>
<span class="co">-- We mostly need this for 'top'.</span>
<span class="kw">instance</span> <span class="dt">MeetSemiLattice</span> <span class="dt">ArgStr</span> <span class="kw">where</span>
  <span class="dt">BottomArgStr</span> <span class="fu">/</span>\ _ <span class="fu">=</span> <span class="dt">BottomArgStr</span>
  _ <span class="fu">/</span>\ <span class="dt">BottomArgStr</span> <span class="fu">=</span> <span class="dt">BottomArgStr</span>
  <span class="dt">TopArgStr</span> <span class="fu">/</span>\ s <span class="fu">=</span> s
  s <span class="fu">/</span>\ <span class="dt">TopArgStr</span> <span class="fu">=</span> s
  (<span class="dt">ConsArgStr</span> s1 a1) <span class="fu">/</span>\ (<span class="dt">ConsArgStr</span> s2 a2) <span class="fu">=</span> <span class="dt">ConsArgStr</span> (s1 <span class="fu">/</span>\ s2) (a1 <span class="fu">/</span>\ a2)

<span class="kw">instance</span> <span class="dt">BoundedMeetSemiLattice</span> <span class="dt">ArgStr</span> <span class="kw">where</span>
  top <span class="fu">=</span> <span class="dt">TopArgStr</span>

<span class="ot">consArgStr ::</span> <span class="dt">Strictness</span> <span class="ot">-&gt;</span> <span class="dt">ArgStr</span> <span class="ot">-&gt;</span> <span class="dt">ArgStr</span>
consArgStr <span class="dt">Lazy</span> <span class="dt">TopArgStr</span>           <span class="fu">=</span> <span class="dt">TopArgStr</span>
consArgStr <span class="dt">HyperStrict</span> <span class="dt">BottomArgStr</span> <span class="fu">=</span> <span class="dt">BottomArgStr</span>
consArgStr s a                      <span class="fu">=</span> <span class="dt">ConsArgStr</span> s a

<span class="ot">unconsArgStr ::</span> <span class="dt">ArgStr</span> <span class="ot">-&gt;</span> (<span class="dt">Strictness</span>, <span class="dt">ArgStr</span>)
unconsArgStr <span class="dt">BottomArgStr</span>     <span class="fu">=</span> (bottom, <span class="dt">BottomArgStr</span>)
unconsArgStr <span class="dt">TopArgStr</span>        <span class="fu">=</span> (top, <span class="dt">TopArgStr</span>)
unconsArgStr (<span class="dt">ConsArgStr</span> s a) <span class="fu">=</span> (s, a)</code></pre></div>
<p>Within this framework, a function like <code>error</code> would have strictness signature <code>ConsArgStr Lazy BottomArgStr</code>, expressing the fact that when it’s applied to one argument, it will not necessarily evaluate that argument, but will lead to an exception (which is the same as divergence, semantically speaking) if the call expression would be evaluated. On the other hand, a lambda like <code>\f -&gt; f a</code> would be denoted by an argument strictness like <code>ConsArgStr (Strict 1) TopArgStr</code>. What about <code>a</code>? That’s tracked in the strictness environment, the other major component of an expression’s strictness type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">StrType</span>
  <span class="fu">=</span> <span class="dt">StrType</span>
  {<span class="ot"> fvs  ::</span> <span class="fu">!</span><span class="dt">StrEnv</span>
  ,<span class="ot"> args ::</span> <span class="fu">!</span><span class="dt">ArgStr</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">JoinSemiLattice</span> <span class="dt">StrType</span> <span class="kw">where</span>
  <span class="dt">StrType</span> fvs1 args1 \<span class="fu">/</span> <span class="dt">StrType</span> fvs2 args2 <span class="fu">=</span>
    <span class="dt">StrType</span> (fvs1 \<span class="fu">/</span> fvs2) (args1 \<span class="fu">/</span> args2)

<span class="kw">instance</span> <span class="dt">BoundedJoinSemiLattice</span> <span class="dt">StrType</span> <span class="kw">where</span>
  bottom <span class="fu">=</span> <span class="dt">StrType</span> bottom bottom

<span class="co">-- | This instance doesn't make a lot of sense semantically,</span>
<span class="co">-- but it's the dual to the 'JoinSemiLattice' instance.</span>
<span class="co">-- We mostly need this for 'top'.</span>
<span class="kw">instance</span> <span class="dt">MeetSemiLattice</span> <span class="dt">StrType</span> <span class="kw">where</span>
  <span class="dt">StrType</span> fvs1 args1 <span class="fu">/</span>\ <span class="dt">StrType</span> fvs2 args2 <span class="fu">=</span>
    <span class="dt">StrType</span> (fvs1 <span class="fu">/</span>\ fvs2) (args1 <span class="fu">/</span>\ args2)

<span class="kw">instance</span> <span class="dt">BoundedMeetSemiLattice</span> <span class="dt">StrType</span> <span class="kw">where</span>
  top <span class="fu">=</span> <span class="dt">StrType</span> top top

<span class="co">-- | This will be used instead of '(/\)' for sequential composition.</span>
<span class="co">-- It's right biased, meaning that it will return the</span>
<span class="co">-- argument strictness of the right argument.</span>
<span class="ot">bothStrType ::</span> <span class="dt">StrType</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span>
bothStrType (<span class="dt">StrType</span> fvs1 _) (<span class="dt">StrType</span> fvs2 args2) <span class="fu">=</span>
  <span class="dt">StrType</span> (fvs1 <span class="fu">/</span>\ fvs2) args2
  
<span class="ot">unitStrType ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Strictness</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span>
unitStrType n s <span class="fu">=</span> <span class="dt">StrType</span> (insertTM n s top) top

<span class="ot">overFVs ::</span> (<span class="dt">StrEnv</span> <span class="ot">-&gt;</span> (a, <span class="dt">StrEnv</span>)) <span class="ot">-&gt;</span> <span class="dt">StrType</span> <span class="ot">-&gt;</span> (a, <span class="dt">StrType</span>)
overFVs f ty <span class="fu">=</span>
  <span class="kw">let</span> (a, fvs') <span class="fu">=</span> f (fvs ty)
  <span class="kw">in</span> (a, ty { fvs <span class="fu">=</span> fvs' })

<span class="ot">peelFV ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span> <span class="ot">-&gt;</span> (<span class="dt">Strictness</span>, <span class="dt">StrType</span>)
peelFV n <span class="fu">=</span> overFVs <span class="fu">$</span> \fvs <span class="ot">-&gt;</span>
  (lookupTM n fvs, deleteTM n fvs)

<span class="ot">modifyFVs ::</span> (<span class="dt">StrEnv</span> <span class="ot">-&gt;</span> <span class="dt">StrEnv</span>) <span class="ot">-&gt;</span> <span class="dt">StrType</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span>
modifyFVs f <span class="fu">=</span> snd <span class="fu">.</span> overFVs (\a <span class="ot">-&gt;</span> ((), f a))

<span class="ot">deleteFV ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span>
deleteFV <span class="fu">=</span> modifyFVs <span class="fu">.</span> deleteTM

<span class="ot">overArgs ::</span> (<span class="dt">ArgStr</span> <span class="ot">-&gt;</span> (a, <span class="dt">ArgStr</span>)) <span class="ot">-&gt;</span> <span class="dt">StrType</span> <span class="ot">-&gt;</span> (a, <span class="dt">StrType</span>)
overArgs f ty <span class="fu">=</span>
  <span class="kw">let</span> (a, args') <span class="fu">=</span> f (args ty)
  <span class="kw">in</span> (a, ty { args <span class="fu">=</span> args' })

<span class="ot">modifyArgs ::</span> (<span class="dt">ArgStr</span> <span class="ot">-&gt;</span> <span class="dt">ArgStr</span>) <span class="ot">-&gt;</span> <span class="dt">StrType</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span>
modifyArgs f <span class="fu">=</span> snd <span class="fu">.</span> overArgs (\a <span class="ot">-&gt;</span> ((), f a))</code></pre></div>
<p>So, strictness environment for free variables, argument strictness for arguments. A last ingredient is an environment that will carry strictness signatures for functions we analysed before:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Arity</span> <span class="fu">=</span> <span class="dt">Int</span>
<span class="kw">type</span> <span class="dt">SigEnv</span> <span class="fu">=</span> <span class="dt">Map</span> <span class="dt">Name</span> (<span class="dt">Arity</span>, <span class="dt">StrType</span>)</code></pre></div>
<p>Any strictness signature is only valid when a certain number of incoming arguments is reached. We store this <em>arity</em> (as in unary, binary, etc.) alongside the strictness signature. Generally, assuming a higher arity can lead to more precise strictness signatures, but applies to less call sites. GHC will only analyse each function once and assume an incoming strictness demand correspond to manifest arity of the function, e.g. the number of top-level lambdas in the RHS of the function’s definition.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Counts the number of top-level lambdas.</span>
<span class="ot">manifestArity ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Arity</span>
manifestArity (<span class="dt">Lam</span> _ e) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> manifestArity e
manifestArity _ <span class="fu">=</span> <span class="dv">0</span></code></pre></div>
<p>That’s it for the lattice! Have a break and enter part 3…</p>
<h2 id="analysis">Analysis</h2>
<p>Let’s define the main analysis function for our core calculus:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">analyse ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span></code></pre></div>
<p>We analyse an expression to find out what strictness it puts its free variables under if put under head-demand:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">analyse <span class="fu">=</span> expr Map.empty <span class="dv">0</span>

<span class="ot">expr ::</span> <span class="dt">SigEnv</span> <span class="ot">-&gt;</span> <span class="dt">Arity</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span>
expr sigs incomingArity <span class="fu">=</span> \<span class="kw">case</span>
  <span class="dt">If</span> b t e <span class="ot">-&gt;</span>
    expr sigs <span class="dv">0</span> b <span class="ot">`bothStrType`</span>
      (expr sigs incomingArity t \<span class="fu">/</span> expr sigs incomingArity e)</code></pre></div>
<p><code>analyse</code> immediately delegates to a more complicated auxiliary function. We’ll first look at the <code>If</code> case here: <code>If</code> will sequentially combine (‘both’) the analysis results from analysing the condition under incoming arity 0 with the result of joining the analysis results of both branches with the arity that came in from outside. Very much what we would expect after our reasoning above!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="dt">App</span> f a <span class="ot">-&gt;</span>
    <span class="kw">let</span>
      fTy <span class="fu">=</span> expr sigs (incomingArity <span class="fu">+</span> <span class="dv">1</span>) f
      (argStr, fTy') <span class="fu">=</span> overArgs unconsArgStr fTy
      aTy <span class="fu">=</span>
        <span class="kw">case</span> argStr <span class="kw">of</span>
          <span class="co">-- bottom = unbounded arity, only possibly constrained by the type</span>
          <span class="co">-- of `a`, which we don't look at here.</span>
          <span class="dt">HyperStrict</span> <span class="ot">-&gt;</span> expr sigs maxBound a
          <span class="dt">Strict</span> n <span class="ot">-&gt;</span> expr sigs n a
          <span class="co">-- `a` is possibly not evaluated at all, so nothing to see there</span>
          <span class="dt">Lazy</span> <span class="ot">-&gt;</span> top
    <span class="kw">in</span> aTy <span class="ot">`bothStrType`</span> fTy'</code></pre></div>
<p>In an application, the head will be analysed with an incremented incoming arity, while the argument is only evaluated if it was put under a strict context. This is determined by examining the strictness type of analysing <code>f</code>.</p>
<p>The resulting types are sequentially combined (‘both’). Note that <code>bothStrType</code> is right-biased and will pass on the argument strictness from <code>fTy'</code>, which is exactly what we want. This will get clearer once we examine the variable case.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="dt">Lam</span> n body <span class="ot">-&gt;</span>
    <span class="kw">let</span>
      bodyTy
        <span class="fu">|</span> incomingArity <span class="fu">&lt;=</span> <span class="dv">0</span> <span class="fu">=</span> top
        <span class="fu">|</span> otherwise <span class="fu">=</span> expr sigs (incomingArity <span class="fu">-</span> <span class="dv">1</span>) body
      <span class="co">-- normally, we would also store the strictness of n in the syntax tree</span>
      <span class="co">-- or in a separate map, but we are only interested in free variables</span>
      <span class="co">-- here for simplicity.</span>
      (str, bodyTy') <span class="fu">=</span> peelFV n bodyTy
    <span class="kw">in</span> modifyArgs (consArgStr str) bodyTy'</code></pre></div>
<p>This is somewhat dual to the application case. Lambdas ‘eat’ arity, so when we run out of arity to feed it, we are not allowed to use analysis results from the body. The only sensible thing to assume is a <code>top</code> strictness type in that case.</p>
<p>The call to <code>peelFV</code> will abstract out the strictness on the argument and we finally cons that strictness onto the argument strictness of the lambda body’s strictness type. Consider what happens for an expression like <code>\f -&gt; f a</code>: The lambda body puts its free variable <code>f</code> under strictness <code>Strict 1</code>, so when we abstract over <code>f</code>, we remove it from <code>fvs</code> and cons it to the lambdas argument strictness instead.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="dt">Var</span> n <span class="ot">-&gt;</span>
    <span class="kw">let</span> sig <span class="fu">=</span> fromMaybe top <span class="fu">$</span> <span class="kw">do</span>
          (arity, sig) <span class="ot">&lt;-</span> Map.lookup n sigs
          guard (arity <span class="fu">&lt;=</span> incomingArity)
          pure sig
    <span class="kw">in</span> bothStrType (unitStrType n (<span class="dt">Strict</span> incomingArity)) sig</code></pre></div>
<p>The variable case will try to look up a signature in the signature environment, check for its compatibility with the incoming arity and fall back to <code>top</code> if any of the guards fail. The resulting signature is combined with a unit strictness type just for this particular call site.</p>
<p>A call to <code>const</code> with two arguments (so <code>arity == 2</code> when we hit the variable) would pass the arity check and return the <code>&lt;S,_&gt;&lt;L,_&gt;</code> (resp. <code>S,L,..</code> in our syntax) signature from above. The application case at any call site would then unleash the proper argument strictness on the concrete argument expressions.</p>
<p>What remains is handling let-bindings. Let’s look at the non-recursive case first:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="dt">Let</span> (<span class="dt">NonRec</span> (name, rhs)) body <span class="ot">-&gt;</span>
    <span class="kw">let</span>
      arity <span class="fu">=</span> manifestArity rhs
      rhsTy <span class="fu">=</span> expr sigs arity rhs
      sigs' <span class="fu">=</span> Map.insert name (arity, rhsTy) sigs
      bodyTy <span class="fu">=</span> expr sigs' incomingArity body
      <span class="co">-- Normally, we would store how 'name' was used in the body somewhere</span>
      bodyTy' <span class="fu">=</span> deleteFV name bodyTy
    <span class="kw">in</span> bodyTy'</code></pre></div>
<p>Even without recursion, this is quite involved. First, we analyse the RHS assuming a call with manifest arity. The resulting strictness type is then inserted into the signature environment for the appropriate arity. The body is analysed with this new signature environment. As <code>rhsTy</code> is unleashed at call sites through the <code>Var</code> case, there is no need to <code>bothStrType</code> the resulting <code>bodyTy'</code> with <code>rhsTy</code> (and would even be wrong, consider the case where the binding is not used strictly).</p>
<p>Fair enough, now onto the recursive case. Typically, this is the case where static analyses <a href="https://en.wikipedia.org/wiki/Rice%27s_theorem">have to yield approximate results in order to stay decidable</a>. Typically, this is achieved through calculating the least fixed-point of the transfer function wrt. to the analysis lattice. Strictness analysis is no different in that regard:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="dt">Let</span> (<span class="dt">Rec</span> binds) body <span class="ot">-&gt;</span>
    <span class="kw">let</span>
      sigs' <span class="fu">=</span> fixBinds sigs binds
      bodyTy <span class="fu">=</span> expr sigs' incomingArity body
      bodyTy' <span class="fu">=</span> foldr deleteFV bodyTy (map fst binds)
    <span class="kw">in</span> bodyTy'</code></pre></div>
<p>That wasn’t so hard! It seems that a few more functions were abstracted into <code>fixBinds</code>, which is responsible for finding a set of sound strictness signatures for the binding group. Let’s see what else hides in <code>fixBinds</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fixBinds ::</span> <span class="dt">SigEnv</span> <span class="ot">-&gt;</span> [(<span class="dt">Name</span>, <span class="dt">Expr</span>)] <span class="ot">-&gt;</span> <span class="dt">SigEnv</span>
fixBinds sigs binds <span class="fu">=</span> toSigEnv stableTypes
  <span class="kw">where</span>
<span class="ot">    names ::</span> [<span class="dt">Name</span>]
    names <span class="fu">=</span> map fst binds

<span class="ot">    toSigEnv ::</span> [(<span class="dt">Arity</span>, <span class="dt">StrType</span>)] <span class="ot">-&gt;</span> <span class="dt">SigEnv</span>
    toSigEnv <span class="fu">=</span> foldr (\(n, ty) <span class="ot">-&gt;</span> Map.insert n ty) sigs <span class="fu">.</span> zip names

<span class="ot">    fromSigEnv ::</span> <span class="dt">SigEnv</span> <span class="ot">-&gt;</span> [(<span class="dt">Arity</span>, <span class="dt">StrType</span>)]
    fromSigEnv sigs <span class="fu">=</span> mapMaybe (flip Map.lookup sigs) names</code></pre></div>
<p>We’ll convert back and forth between the <code>SigEnv</code> representation and the list of points of the <code>SigEnv</code> that are actually subject to change. <code>toSigEnv</code> converts the points of the current binding group into a proper <code>SigEnv</code> by adding them to the incoming <code>SigEnv</code>, which contains strictness signatures for outer bindings.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    stableTypes ::</span> [(<span class="dt">Arity</span>, <span class="dt">StrType</span>)]
    stableTypes <span class="fu">=</span>
      fst
      <span class="fu">.</span> head
      <span class="fu">.</span> filter (uncurry (<span class="fu">==</span>))
      <span class="fu">$</span> zip approximations (tail approximations)

<span class="ot">    start ::</span> [(<span class="dt">Arity</span>, <span class="dt">StrType</span>)]
    start <span class="fu">=</span> map (const (<span class="dv">0</span>, bottom)) binds

<span class="ot">    approximations ::</span> [[(<span class="dt">Arity</span>, <span class="dt">StrType</span>)]]
    approximations <span class="fu">=</span> iterate iter start</code></pre></div>
<p>This part is concerned with finding the fixed-point of <code>iter</code>, beginning with an optimistic approximation <code>start</code>, where all bindings are approximated by <code>bottom</code>. We have found a fixed-point as soon as <code>approximations</code> becomes stable. This is detected by <code>stableTypes</code>, which we converted into the result of <code>fixBinds</code> above.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    iter ::</span> [(<span class="dt">Arity</span>, <span class="dt">StrType</span>)] <span class="ot">-&gt;</span> [(<span class="dt">Arity</span>, <span class="dt">StrType</span>)]
    iter tys <span class="fu">=</span> fromSigEnv (foldr iterBind (toSigEnv tys) binds)

    iterBind (name, rhs) sigs' <span class="fu">=</span>
      <span class="kw">let</span>
        arity <span class="fu">=</span> manifestArity rhs
        rhsTy <span class="fu">=</span> expr sigs' (manifestArity rhs) rhs
        rhsTy' <span class="fu">=</span> foldr deleteFV rhsTy names
      <span class="kw">in</span> Map.insert name (arity, rhsTy') sigs'</code></pre></div>
<p>Aha, so <code>iterBind</code> is where the logic from the non-recursive case ended up! The other functions were just a big build up to set up fixed-point iteration. We compute iterated approximations of the signature environment until we hit the fixed-point, at which point we have a sound approximation of program semantics.</p>
<h2 id="test-drive">Test-drive</h2>
<p>Phew! That’s it. Let’s put our function to work.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">a, b, c,<span class="ot"> f ::</span> <span class="dt">Expr</span>
(a<span class="fu">:</span>b<span class="fu">:</span>c<span class="fu">:</span>_<span class="fu">:</span>_<span class="fu">:</span>f<span class="fu">:</span>_) <span class="fu">=</span> map (<span class="dt">Var</span> <span class="fu">.</span> (<span class="fu">:</span>[])) [<span class="ch">'a'</span><span class="fu">..</span>]

<span class="ot">exprs ::</span> [<span class="dt">Expr</span>]
exprs <span class="fu">=</span>
  [ <span class="dt">If</span> a b c
  , <span class="dt">If</span> a b b
  , <span class="dt">If</span> a (<span class="dt">App</span> f b) (<span class="dt">App</span> f c)
  , <span class="dt">App</span> (<span class="dt">Lam</span> <span class="st">&quot;b&quot;</span> b) a
  , <span class="dt">Let</span> (<span class="dt">NonRec</span> (<span class="st">&quot;f&quot;</span>, <span class="dt">Lam</span> <span class="st">&quot;b&quot;</span> b)) (<span class="dt">App</span> f a)
  , <span class="dt">Let</span> (<span class="dt">Rec</span> [(<span class="st">&quot;f&quot;</span>, <span class="dt">Lam</span> <span class="st">&quot;b&quot;</span> (<span class="dt">App</span> f b))]) (<span class="dt">App</span> f a)
  , <span class="dt">Let</span> (<span class="dt">Rec</span> [(<span class="st">&quot;f&quot;</span>, <span class="dt">Lam</span> <span class="st">&quot;b&quot;</span> (<span class="dt">If</span> b c (<span class="dt">App</span> f b)))]) (<span class="dt">App</span> f a)
  ]

main <span class="fu">=</span> forM_ exprs <span class="fu">$</span> \e <span class="ot">-&gt;</span> <span class="kw">do</span>
  print e
  print (analyse e)
  putStrLn <span class="st">&quot;&quot;</span></code></pre></div>
<p>This is its output:</p>
<pre class="unknown"><code>If (Var &quot;a&quot;) (Var &quot;b&quot;) (Var &quot;c&quot;)
StrType {fvs = TotalMap {def = L, points = fromList [(&quot;a&quot;,S)]}, args = L,L..}

If (Var &quot;a&quot;) (Var &quot;b&quot;) (Var &quot;b&quot;)
StrType {fvs = TotalMap {def = L, points = fromList [(&quot;a&quot;,S),(&quot;b&quot;,S)]}, args = L,L..}

If (Var &quot;a&quot;) (App (Var &quot;f&quot;) (Var &quot;b&quot;)) (App (Var &quot;f&quot;) (Var &quot;c&quot;))
StrType {fvs = TotalMap {def = L, points = fromList [(&quot;a&quot;,S),(&quot;f&quot;,S(S))]}, args = L,L..}

App (Lam &quot;b&quot; (Var &quot;b&quot;)) (Var &quot;a&quot;)
StrType {fvs = TotalMap {def = L, points = fromList [(&quot;a&quot;,S)]}, args = L,L..}

Let (NonRec (&quot;f&quot;,Lam &quot;b&quot; (Var &quot;b&quot;))) (App (Var &quot;f&quot;) (Var &quot;a&quot;))
StrType {fvs = TotalMap {def = L, points = fromList [(&quot;a&quot;,S)]}, args = L,L..}

Let (Rec [(&quot;f&quot;,Lam &quot;b&quot; (App (Var &quot;f&quot;) (Var &quot;b&quot;)))]) (App (Var &quot;f&quot;) (Var &quot;a&quot;))
StrType {fvs = TotalMap {def = B, points = fromList []}, args = B,B..}

Let (Rec [(&quot;f&quot;,Lam &quot;b&quot; (If (Var &quot;b&quot;) (Var &quot;c&quot;) (App (Var &quot;f&quot;) (Var &quot;b&quot;))))]) (App (Var &quot;f&quot;) (Var &quot;a&quot;))
StrType {fvs = TotalMap {def = L, points = fromList [(&quot;a&quot;,S),(&quot;c&quot;,S)]}, args = L,L..}</code></pre>
<p>The first two test-cases are concerned with testing the <code>If</code> case. The next two expressions test <code>App</code>lications and <code>Lam</code>das, most importantly correct handling of incoming arity. Note how this correctly infers that <code>a</code> was used strictly in the fourth example. What follows is a non-recursive let-binding, basically doing the same as the fourth expression.</p>
<p>The last two expressions show-case what this simple analysis is able to infer. First, there’s a nonterminating <code>let f b = f b in f a</code> which is correctly denoted by <code>bot</code>tom. This already hints that our analysis is able carry out some inductive reasoning. The last example then analyses <code>let f b = if b then c else f b in f a</code> to find out that both <code>a</code> and <code>c</code> are used strictly. Cool!</p>
<h2 id="conclusion">Conclusion</h2>
<p>We defined a projection-based strictness analysis in the style of GHC that actually finds out useful things about our code!</p>
<p>I hope that in doing so, you got a feeling about what GHC can and cannot derive about the performance critical code you write. Specifically, looking back at the problem in <a href="../blog/2017-12-04-strictness-analysis-part-1.html">part 1</a>, you should now be able to see why we needed a bang in <code>printAverage</code> and how that enables GHC to infer that the accumulator can be completely unboxed. This is just by mechanically following the analysis rules above!</p>
<p>Granted, there are many details in which GHC’s demand analyser (which does strictness analysis) differs from the analysis above:</p>
<ul>
<li>Local, non-recursive thunk bindings have a different analysis rule than functions</li>
<li>We ignore product demands like <code>S(LS(S))</code> for simplicity, but it’s straight-forward to extend</li>
<li>Various hacks and special cases that you can ignore in 95% of all cases</li>
</ul>
<p>If you want to know more about these details, read the following papers:</p>
<ul>
<li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/demand.pdf">Complete, but dated report on the demand analyser</a>. This is probably the best paper for having an overview of what GHC does today in 95% of all cases.</li>
<li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2017/03/demand-jfp-draft.pdf">Incomplete, but recent report on the demand analyser</a></li>
<li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2014/01/cardinality-popl14.pdf">Complete, recent report on usage analysis (dual to strictness) within the demand analyser</a></li>
</ul>
<p>I agree if you say that the documentation story is a little insatisfying. Anyway, the ultimate reference is always the code of <a href="https://gitlab.haskell.org/ghc/ghc/blob/master/compiler/stranal/DmdAnal.hs">the demand analyser within GHC itself</a>.</p>
<p>If/when I come around to it, I can finally pitch you my <a href="https://hackage.haskell.org/package/datafix"><code>datafix</code> library</a> for computing fixed-points like we just did in a more principled way. So stay stuned for part 4 :)</p>
<p><b id="f1">1</b> … 2017<a href="#a1">↩</a></p>
</section>
<div id="disqus_thread"></div>
<script>
  /**
  *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
  *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
  /*
  var disqus_config = function () {
  this.page.url = fixpt.de/blog/2018-12-30-strictness-analysis-part-2.html;  // Replace PAGE_URL with your page's canonical URL variable
  this.page.identifier = /blog/2018-12-30-strictness-analysis-part-2.html; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
  };
  */
  (function () { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://fixpt.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
        </div>

        <footer id="footer">
            <section>
                <form method="POST" action="https://formspree.io/sgraf1337@gmail.com">
                    <div class="field">
                        <label for="name">Name</label>
                        <input type="text" name="name" id="name" />
                    </div>
                    <div class="field">
                        <label for="email">Email</label>
                        <input type="text" name="email" id="email" />
                    </div>
                    <div class="field">
                        <label for="message">Message</label>
                        <textarea name="message" id="message" rows="3"></textarea>
                    </div>
                    <ul class="actions">
                        <li>
                            <input type="submit" value="Send Message" />
                        </li>
                    </ul>
                </form>
            </section>
            <section class="split contact">
                <section>
                    <h3>E-mail</h3>
                    <p>
                        <a href="mailto:sgraf1337@gmail.com">sgraf1337@gmail.com</a>
                    </p>
                </section>
                <section>
                    <h3>Social</h3>
                    <ul class="icons alt">
                        <li>
                            <a href="https://reddit.com/user/sgraf812" class="icon fa-reddit" rel="nofollow">
                                <span class="label">Reddit</span>
                            </a>
                        </li>
                        <li>
                            <a href="https://github.com/sgraf812" class="icon fa-github" rel="nofollow">
                                <span class="label">GitHub</span>
                            </a>
                        </li>
                        <li>
                            <a href="https://twitter.com/sgraf1337" class="icon fa-twitter" rel="nofollow">
                                <span class="label">Twitter</span>
                            </a>
                        </li>
                    </ul>
                </section>
            </section>
        </footer>
        <!-- Copyright -->
        <div id="copyright">
            <ul>
                <li>&copy; HTML5 UP</li>
                <li>Design by
                    <a href="https://html5up.net">HTML5 UP</a>
                </li>
                <li>Adapted from the Jekyll integration by
                    <a href="https://somiibo.com">Somiibo</a>
                </li>
                <li>Powered by
                    <a href="http://jaspervdj.be/hakyll">Hakyll</a>
                </li>
                </li>
            </ul>
        </div>
    </div>
</body>

</html>
