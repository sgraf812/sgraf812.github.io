<!DOCTYPE html>
<html lang="en">

<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>fixpt &middot; All About Strictness Analysis (part 1)</title>

  <link rel="canonical" href="../blog/2017-12-04-strictness-analysis-part-1.html">

  <link rel="apple-touch-icon-precomposed" sizes="180x180" href="../assets/icon/apple-touch-icon.png">
  <link rel="shortcut icon" href="../assets/icon/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="../assets/icon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../assets/icon/favicon-16x16.png">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="../atom.xml">

  <!-- CSS -->
  <link rel="stylesheet" href="../assets/css/poole.css" />
  <link rel="stylesheet" href="../assets/css/syntax.css" />
  <link rel="stylesheet" href="../assets/css/lanyon.css" />
  <link rel="stylesheet" href="../assets/css/custom.css" />
  <link rel="stylesheet" href="../assets/css/pygments.css" />
  <link rel="stylesheet" href="https://fonts.cdnfonts.com/css/linux-libertine-o">
  <link rel="stylesheet" href="https://fonts.cdnfonts.com/css/linux-biolinum">
  <script src="https://kit.fontawesome.com/75227a9ab1.js" crossorigin="anonymous"></script>

<!--
    <link rel="stylesheet" href="/assets/css/main.css" />
    <noscript>
        <link rel="stylesheet" href="/assets/css/noscript.css" />
    </noscript>
-->
</head>

<body>

<header class="masthead">
  <nav class="nav-bar" role="navigation">
    <ul class="nav-items left">
      <li><a class="nav-item active" href="../">Blog</a>
      </li>
      <li><a class="nav-item " href="../about.html">About</a>
      </li>
    </ul>

    <ul class="nav-items center container">
      <li class="masthead-title">
        <a href="../" title="Home">fixpt.de</a> <small>Sebastian Graf</small>
      </li>
    </ul>

    <ul class="nav-items right">
      <li><a href="https://github.com/sgraf812" class="fa-brands fa-github" rel="nofollow"></a></li>
      <li><a href="https://x.com/sgraf1337" class="fa-brands fa-x-twitter" rel="nofollow"></a></li>
      <li><a href="https://mastodon.online/@sgraf" class="fa-brands fa-mastodon" rel="nofollow"></a></li>
      <li><a href="https://orcid.org/0000-0001-9074-9055" class="fa-brands fa-orcid" rel="nofollow"></a></li>
    </ul>
  </nav>
</header>

<section role="main" class="container content">
  <div class="post">
  <h1 class="post-title">All About Strictness Analysis (part 1)</h1>
  <span class="post-date">December  4, 2017</span>
  <p>Non-strict languages like Haskell often require the programmer to reason about strictness to achieve good performance.
A while ago, Michael Snoyman wrote a <a href="https://www.fpcomplete.com/blog/2017/09/all-about-strictness">blog post</a> about this, giving an introduction on the matter as well as an overview over the tools at our disposal.</p>
<p>In this post, I want to offer another, more surgical approach to plugging space leaks that works hand in hand with optimizations carried out by the compiler.</p>
<!--more-->
<h2 id="the-setting">The Setting</h2>
<p>Michael Snoyman fixed problems due to laziness by making ample use of strictness annotations.
This is the right approach when you run into space leaks in debug builds.
It’s also good practice for library writers, where you cannot anticipate usage patterns, so the least you could do is force strict parameters as early as possible.</p>
<p>Running example in Snoyman’s blog post were variants of the following program computing the average of a list of <code>Int</code>egers:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RunningTotal</span> <span class="ot">=</span> <span class="dt">RunningTotal</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> sum   ::</span> <span class="dt">Int</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> count ::</span> <span class="dt">Int</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ot">printAverage ::</span> <span class="dt">RunningTotal</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>printAverage (<span class="dt">RunningTotal</span> <span class="fu">sum</span> count)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> count <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Need at least one value!&quot;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">print</span> (<span class="fu">fromIntegral</span> <span class="fu">sum</span> <span class="op">/</span> <span class="fu">fromIntegral</span><span class="ot"> count ::</span> <span class="dt">Double</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="ot">printListAverage ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>printListAverage <span class="ot">=</span> go (<span class="dt">RunningTotal</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    go rt [] <span class="ot">=</span> printAverage rt</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    go (<span class="dt">RunningTotal</span> <span class="fu">sum</span> count) (x<span class="op">:</span>xs) <span class="ot">=</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>      go (<span class="dt">RunningTotal</span> (<span class="fu">sum</span> <span class="op">+</span> x) (count <span class="op">+</span> <span class="dv">1</span>)) xs</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> printListAverage [<span class="dv">1</span><span class="op">..</span><span class="dv">1000000</span>]</span></code></pre></div>
<p>In absence of any optimization, this is quite hungry for memory:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack <span class="at">--resolver</span><span class="op">=</span>nightly-2017-12-01 ghc <span class="at">--</span> <span class="at">-O0</span> average.hs <span class="kw">&amp;&amp;</span> <span class="ex">./average</span> +RTS <span class="at">-s</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ex">500000.5</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>     <span class="ex">258,650,856</span> bytes allocated in the heap</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>     <span class="ex">348,098,952</span> bytes copied during GC</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>      <span class="ex">74,388,992</span> bytes maximum residency <span class="er">(</span><span class="ex">9</span> sample<span class="er">(</span><span class="ex">s</span><span class="kw">))</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>         <span class="ex">599,832</span> bytes maximum slop</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>             <span class="ex">179</span> MB total memory in use <span class="er">(</span><span class="ex">0</span> MB lost due to fragmentation<span class="kw">)</span></span></code></pre></div>
<p>Significant numbers are roughly 250MB in allocations over the course of execution, as well as a maximum working set of 74MB.
I’m currently on stackage <code>nightly-2017-12-01</code> (GHC 8.2.2) on a Windows box, which might explain differences in measurement.</p>
<p>The post goes on to annotate the accumulating parameter of <code>go</code> with bang patterns:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RunningTotal</span> <span class="ot">=</span> <span class="dt">RunningTotal</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> sum   ::</span> <span class="dt">Int</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> count ::</span> <span class="dt">Int</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="ot">printAverage ::</span> <span class="dt">RunningTotal</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>printAverage (<span class="dt">RunningTotal</span> <span class="fu">sum</span> count)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> count <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Need at least one value!&quot;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">print</span> (<span class="fu">fromIntegral</span> <span class="fu">sum</span> <span class="op">/</span> <span class="fu">fromIntegral</span><span class="ot"> count ::</span> <span class="dt">Double</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="ot">printListAverage ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>printListAverage <span class="ot">=</span> go (<span class="dt">RunningTotal</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    go rt [] <span class="ot">=</span> printAverage rt</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    go (<span class="dt">RunningTotal</span> <span class="op">!</span><span class="fu">sum</span> <span class="op">!</span>count) (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="co">-- only this line changed</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>      go (<span class="dt">RunningTotal</span> (<span class="fu">sum</span> <span class="op">+</span> x) (count <span class="op">+</span> <span class="dv">1</span>)) xs</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> printListAverage [<span class="dv">1</span><span class="op">..</span><span class="dv">1000000</span>]</span></code></pre></div>
<p>This has a great effect on maximum residency:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack <span class="at">--resolver</span><span class="op">=</span>nightly-2017-12-01 ghc <span class="at">--</span> <span class="at">-O0</span> average.hs <span class="kw">&amp;&amp;</span> <span class="ex">./average</span> +RTS <span class="at">-s</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ex">500000.5</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>     <span class="ex">192,099,048</span> bytes allocated in the heap</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>         <span class="ex">245,416</span> bytes copied during GC</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>          <span class="ex">42,856</span> bytes maximum residency <span class="er">(</span><span class="ex">2</span> sample<span class="er">(</span><span class="ex">s</span><span class="kw">))</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>          <span class="ex">30,872</span> bytes maximum slop</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>               <span class="ex">2</span> MB total memory in use <span class="er">(</span><span class="ex">0</span> MB lost due to fragmentation<span class="kw">)</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="ex">INIT</span>    time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="ex">MUT</span>     time    0.031s  <span class="er">(</span>  <span class="ex">0.029s</span> elapsed<span class="kw">)</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="ex">GC</span>      time    0.000s  <span class="er">(</span>  <span class="ex">0.001s</span> elapsed<span class="kw">)</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="ex">EXIT</span>    time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="ex">Total</span>   time    0.031s  <span class="er">(</span>  <span class="ex">0.030s</span> elapsed<span class="kw">)</span></span></code></pre></div>
<p>The program now executes in constant residency, which, in the presence of garbage collection, guarantees constant space usage! Nonetheless, we still produce a lot of garbage (190MB) and need 30ms to arrive at that result.</p>
<h2 id="optimizations">Optimizations</h2>
<p>Compare that to what happens when we compile with optimizations on:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack <span class="at">--resolver</span><span class="op">=</span>nightly-2017-12-01 ghc <span class="at">--</span> <span class="at">-O2</span> average.hs <span class="kw">&amp;&amp;</span> <span class="ex">./average</span> +RTS <span class="at">-s</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ex">500000.5</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>     <span class="ex">128,098,744</span> bytes allocated in the heap</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>          <span class="ex">13,800</span> bytes copied during GC</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>          <span class="ex">42,856</span> bytes maximum residency <span class="er">(</span><span class="ex">1</span> sample<span class="er">(</span><span class="ex">s</span><span class="kw">))</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>          <span class="ex">30,872</span> bytes maximum slop</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>               <span class="ex">2</span> MB total memory in use <span class="er">(</span><span class="ex">0</span> MB lost due to fragmentation<span class="kw">)</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="ex">INIT</span>    time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="ex">MUT</span>     time    0.016s  <span class="er">(</span>  <span class="ex">0.014s</span> elapsed<span class="kw">)</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="ex">GC</span>      time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="ex">EXIT</span>    time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="ex">Total</span>   time    0.016s  <span class="er">(</span>  <span class="ex">0.015s</span> elapsed<span class="kw">)</span></span></code></pre></div>
<p>Optimizations chipped off a huge amount of total allocations and also cut execution time in half.</p>
<p>How can we improve on this? By deleting the two bangs we inserted earlier (simply for dramatic effect) and placing one in the pattern of <code>printAverage</code> instead:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RunningTotal</span> <span class="ot">=</span> <span class="dt">RunningTotal</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> sum   ::</span> <span class="dt">Int</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> count ::</span> <span class="dt">Int</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="ot">printAverage ::</span> <span class="dt">RunningTotal</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>printAverage (<span class="dt">RunningTotal</span> <span class="op">!</span><span class="fu">sum</span> count) <span class="co">-- New bang here</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> count <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Need at least one value!&quot;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">print</span> (<span class="fu">fromIntegral</span> <span class="fu">sum</span> <span class="op">/</span> <span class="fu">fromIntegral</span><span class="ot"> count ::</span> <span class="dt">Double</span>)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="ot">printListAverage ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>printListAverage <span class="ot">=</span> go (<span class="dt">RunningTotal</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    go rt [] <span class="ot">=</span> printAverage rt</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    go (<span class="dt">RunningTotal</span> <span class="fu">sum</span> count) (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="co">-- No more bangs here</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>      go (<span class="dt">RunningTotal</span> (<span class="fu">sum</span> <span class="op">+</span> x) (count <span class="op">+</span> <span class="dv">1</span>)) xs</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> printListAverage [<span class="dv">1</span><span class="op">..</span><span class="dv">1000000</span>]</span></code></pre></div>
<p>Compile and execute this in old fashion with optimizations on:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack <span class="at">--resolver</span><span class="op">=</span>nightly-2017-12-01 ghc <span class="at">--</span> <span class="at">-O2</span> average.hs <span class="kw">&amp;&amp;</span> <span class="ex">./average</span> +RTS <span class="at">-s</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ex">500000.5</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>      <span class="ex">80,098,744</span> bytes allocated in the heap</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>           <span class="ex">5,864</span> bytes copied during GC</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>          <span class="ex">42,856</span> bytes maximum residency <span class="er">(</span><span class="ex">1</span> sample<span class="er">(</span><span class="ex">s</span><span class="kw">))</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>          <span class="ex">30,872</span> bytes maximum slop</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>               <span class="ex">2</span> MB total memory in use <span class="er">(</span><span class="ex">0</span> MB lost due to fragmentation<span class="kw">)</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="ex">INIT</span>    time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="ex">MUT</span>     time    0.000s  <span class="er">(</span>  <span class="ex">0.009s</span> elapsed<span class="kw">)</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="ex">GC</span>      time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="ex">EXIT</span>    time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="ex">Total</span>   time    0.000s  <span class="er">(</span>  <span class="ex">0.009s</span> elapsed<span class="kw">)</span></span></code></pre></div>
<p>Another huge chunk of allocations is gone and execution time reduced by at least 30% again! What just happened?</p>
<h2 id="the-compiler-can-reason-about-strictness">The compiler can reason about strictness</h2>
<p>The strictness analysis of GHC (which is integrated in its <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Demand">Demand Analyzer</a>, a behemoth that interleaves three different analyses) is quite capable.
Without any intervention it would have recognized that the recursive <code>go</code> is strict not only in the <code>RunningTotal</code> constructor, but also in its <code>count</code> field.
Perhaps surprisingly, it would find the <code>sum</code> field <em>not</em> to be evaluated strictly.</p>
<p>That’s due to a subtlety in the definition of <code>printAverage</code>:
Note that in the <code>count == 0</code> error case that <code>sum</code> isn’t evaluated at all!
And indeed, <code>printAverage (RunningTotal undefined 0)</code> will print the expected error message instead of crashing due to <code>undefined</code>, which is the very definition of being lazy in <code>sum</code>.
This extends to a call like <code>go (RunningTotal undefined 0) []</code>, so GHC can’t just unbox the <code>sum</code> field even if the recursive case of <code>go</code> is annotated.
So placing a bang in <code>printAverage</code> makes sense after all:
There isn’t much utility in allowing calls like <code>printAverage (RunningTotal undefined 0)</code>.</p>
<p>What I found quite essential to pin down the cause of this performance regression is a combination of looking at the GHC Core output as well as reproduce what strictness analysis found out.
Let’s start with a crash course on a simple strictness analysis similar to GHC’s.</p>
<p>In order to be scalable, GHC summarizes each function by a <em>demand signature</em> (consult the <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Demand">GHC wiki page</a> for details), part of which relates how a single call evaluates its arguments and free variables.
The signature for <code>printAverage</code> for example looks like <code>&lt;S(LS(S)),_&gt;</code> (we elide usage demands, suggested by the <code>_</code> wildcard), which reads as:
When <code>printAverage</code> is called with one argument, it will evaluate that argument strictly (the <code>RunningTotal</code> box), as well as unpack the boxed <code>Int</code> in its second field (<code>count</code>) strictly, while being <code>L</code>azy in the first field (<code>sum</code>).</p>
<p>It’s not hard to see how to arrive at that signature:
We (and the compiler) assume a call with one argument (ignoring intricacies regarding <code>IO</code>), and see that the first branch is lazy in <code>sum</code>, while the second is strict in both.
Prior to that, the <code>RunningTotal</code> is unpacked (evaluated!) and <code>count</code> is compared to 0, which also entails unpacking the <code>Int</code> constructor to get at the unboxed <code>Int#</code>.
Combined, <code>RunningTotal</code>s <code>count</code> field is put under strictness <code>S(S)</code> (the unpacked <code>Int#</code> in the box is evaluated strictly), while <code>sum</code> is put under strictness <code>L</code>, resulting in said strictness demand of <code>S(LS(S))</code> on the <code>RunningTotal</code> argument.</p>
<p>Non-recursive functions are trivial to analyze and are inlined most of the time anyway.
What about a recursive function, such as <code>go</code>?
Let’s see what GHC found out by dumping the module’s Core IR after the strictness analyzer has been run with <code>-ddump-stranal</code> (simplified):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> stack <span class="co">--resolver=nightly-2017-12-01 ghc -- -O2 average.hs -ddump-stranal -fforce-recomp</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span>             ( average<span class="op">.</span>hs, average<span class="op">.</span>o )</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">====================</span> <span class="dt">Demand</span> analysis <span class="op">====================</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="ot">go ::</span> <span class="dt">RunningTotal</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>[<span class="op">...</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a> <span class="dt">Arity</span><span class="ot">=</span><span class="dv">2</span>,</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a> <span class="dt">Str</span><span class="op">=&lt;</span><span class="dt">S</span>(<span class="dt">LS</span>(<span class="dt">S</span>)),<span class="dv">1</span><span class="op">*</span><span class="dt">U</span>(<span class="dv">1</span><span class="op">*</span><span class="dt">U</span>(<span class="dt">U</span>),<span class="dv">1</span><span class="op">*</span><span class="dt">U</span>(<span class="dt">U</span>))<span class="op">&gt;&lt;</span><span class="dt">S</span>,<span class="dv">1</span><span class="op">*</span><span class="dt">U</span><span class="op">&gt;</span>,</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a> <span class="op">...</span>]</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>go</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> \ (<span class="ot">rt ::</span> <span class="dt">RunningTotal</span>)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>      (<span class="ot">xs ::</span> [<span class="dt">Int</span>]) <span class="ot">-&gt;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> xs <span class="kw">of</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        [] <span class="ot">-&gt;</span> <span class="co">-- inlining of `printAverage rt`</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> x xs <span class="ot">-&gt;</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>          <span class="kw">case</span> rt <span class="kw">of</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">RunningTotal</span> <span class="fu">sum</span> count <span class="ot">-&gt;</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>              go</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>                (<span class="dt">Main.RunningTotal</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>                  (<span class="op">GHC.Num.$</span>fNumInt_<span class="op">$</span>c<span class="op">+</span> <span class="fu">sum</span> x)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>                  (<span class="kw">case</span> count <span class="kw">of</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">GHC.Types.I</span><span class="op">#</span> count<span class="op">#</span> <span class="ot">-&gt;</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">GHC.Types.I</span><span class="op">#</span> (<span class="op">GHC.Prim.+#</span> count<span class="op">#</span> <span class="dv">1</span><span class="op">#</span>)))</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>                xs</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a><span class="op">====================</span> <span class="dt">Demand</span> analysis <span class="op">====================</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>Note that there are multiple runs of the demand analyzer, but we’ll focus on the first run for now, before any of the strictness information was exploited by transformations downstream.</p>
<p>Crucial is the demand signature assigned to <code>go</code>, which is available as the <code>Str</code> attribute (usage demands elided again): <code>&lt;S(LS(S)),_&gt;&lt;S,_&gt;</code>.
This is just as expected.
The first <code>RunningTotal</code> argument is unpacked all the time (in the <code>[]</code> case, that’s done by <code>printAverage</code>), but its <code>sum</code> field is only evaluated lazily because the error case in <code>printAverage</code> isn’t strict in it, so by induction, <code>go</code> is neither.
The second argument is the list of integers to average, which we immediately match on, so naturally its outer constructor is used strictly.</p>
<p>It’s one thing for humans to reason like this, but how do we teach this to a compiler?
The key here is inductive reasoning: Under the assumption that <code>go</code> has the above demand signature to be unleashed at recursive call sites, we can indeed verify <code>go</code> has this signature.</p>
<p>For that, the compiler initially assumes the most <em>optimistic</em> demand signature possible for <code>go</code>, which corresponds to <code>&lt;S(S(S)S(S)),_&gt;&lt;S,_&gt;</code><sup id="a1"><a href="#f1">1</a></sup>, the demand a <code>deepseq</code> would put on the arguments.
Assuming this for the recursive case, we can see that the newly constructed <code>RunningTotal (sum + x) (count + 1)</code> is <code>deepseq</code>ed immediately, which translates into a strictness of <code>S(S)</code> on both fields of the <code>RunningTotal</code> argument.</p>
<p>In the base case, however, the call to <code>printAverage</code> causes the <code>count</code> field to only be evaluated lazily.
That’s enough for the whole case match to be lazy in <code>count</code>, so the computed strictness signature is <code>&lt;S(LS(S)),_&gt;&lt;S,_&gt;</code>.
Now the compiler has to reiterate analysis of <code>go</code>, because the assumed signature was too optimistic.
Fortunately, under the assumption of <code>&lt;S(LS(S)),_&gt;&lt;S,_&gt;</code> for the recursive call, we arrive at exactly the same signature.
Analysis has reached a <em>fixed-point</em> in its endeavour to find a conservative approximation for the strictness properties of <code>go</code> at runtime.</p>
<h2 id="all-boxes-must-go">All boxes must go</h2>
<p>Having a basic understanding of how strictness analysis works, we see that <code>printAverage</code> is the reason why <code>sum</code> isn’t unboxed.
As soon as we add the bang in the relevant position, as I foreshadowed above, we arrive at the following, simplified Core output:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> stack <span class="co">--resolver=nightly-2017-12-01 ghc -- -O2 average.hs -ddump-simpl -fforce-recomp</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>Main.main_<span class="op">$</span>s<span class="op">$</span>wgo</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>[<span class="dt">GblId</span>, <span class="dt">Arity</span><span class="ot">=</span><span class="dv">3</span>, <span class="dt">Str</span><span class="op">=&lt;</span><span class="dt">S</span>,<span class="dv">1</span><span class="op">*</span><span class="dt">U</span><span class="op">&gt;&lt;</span><span class="dt">S</span>,<span class="dt">U</span><span class="op">&gt;&lt;</span><span class="dt">L</span>,<span class="dt">U</span><span class="op">&gt;</span>]</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>Main.main_<span class="op">$</span>s<span class="op">$</span>wgo</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> \ (<span class="ot">xs ::</span> [<span class="dt">Int</span>])</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>      (<span class="ot">count ::</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>      (<span class="fu">sum</span><span class="ot"> ::</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span>) <span class="ot">-&gt;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> xs <span class="kw">of</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        [] <span class="ot">-&gt;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>          <span class="kw">case</span> count <span class="kw">of</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            <span class="dv">0</span><span class="op">#</span> <span class="ot">-&gt;</span> lvl2_r4lk <span class="co">-- error &quot;...&quot;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>            _ <span class="ot">-&gt;</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>              (GHC.IO.Handle.Text.hPutStr2</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>                 GHC.IO.Handle.FD.stdout</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>                 (<span class="kw">case</span> <span class="op">GHC.Prim./##</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>                         (GHC.Prim.int2Double<span class="op">#</span> <span class="fu">sum</span>) (GHC.Prim.int2Double<span class="op">#</span> wild1_X1r)</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">of</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>                    _ <span class="ot">-&gt;</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>                      <span class="op">GHC.Float.$</span>w<span class="op">$</span>sshowSignedFloat</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>                        <span class="op">GHC.Float.$</span>fShowDouble2</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>                        GHC.Float.minExpt</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>                        wild4_a3Qb</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>                        (<span class="dt">GHC.Types</span><span class="op">.</span>[] <span class="op">@</span> <span class="dt">Char</span>))</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>                 <span class="dt">GHC.Types.True</span>)</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> x xs <span class="ot">-&gt;</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>          <span class="op">$</span>wgo_r4ll</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>            (<span class="kw">case</span> x <span class="kw">of</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>              <span class="dt">GHC.Types.I</span><span class="op">#</span> y <span class="ot">-&gt;</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>                <span class="dt">GHC.Types.I</span><span class="op">#</span> (<span class="op">GHC.Prim.+#</span> <span class="fu">sum</span> y))</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>            (<span class="op">GHC.Prim.+#</span> count <span class="dv">1</span><span class="op">#</span>)</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>            xs</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>Note that the <code>RunningTotal</code> box is completely gone.
That’s due to GHC optimizing away repeated boxing and unboxing in its <a href="http://www.cs.nott.ac.uk/~pszgmh/wrapper-extended.pdf">worker/wrapper transformation</a>, which is the pass that profits most significantly from strictness information. Without strictness analysis, no unboxing happens, even if you annotate bindings with bangs or activate <code>-XStrict</code>.</p>
<p>All 80MB of remaining allocation (we measured this above) are due to the list of integers.
We can do better by recognizing the fold pattern in <code>go</code> and make use of <code>foldl</code> (that’s right, it even works with the lazy one!), which takes part in list fusion since GHC 7.10:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RunningTotal</span> <span class="ot">=</span> <span class="dt">RunningTotal</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> sum   ::</span> <span class="dt">Int</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> count ::</span> <span class="dt">Int</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="ot">printAverage ::</span> <span class="dt">RunningTotal</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>printAverage (<span class="dt">RunningTotal</span> <span class="op">!</span><span class="fu">sum</span> count)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> count <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Need at least one value!&quot;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">print</span> (<span class="fu">fromIntegral</span> <span class="fu">sum</span> <span class="op">/</span> <span class="fu">fromIntegral</span><span class="ot"> count ::</span> <span class="dt">Double</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="ot">printListAverage ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>printListAverage <span class="ot">=</span> printAverage <span class="op">.</span> <span class="fu">foldl</span> f (<span class="dt">RunningTotal</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    f (<span class="dt">RunningTotal</span> <span class="fu">sum</span> count) x <span class="ot">=</span> <span class="dt">RunningTotal</span> (<span class="fu">sum</span> <span class="op">+</span> x) (count <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> printListAverage [<span class="dv">1</span><span class="op">..</span><span class="dv">1000000</span>]</span></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack <span class="at">--resolver</span><span class="op">=</span>nightly-2017-12-01 ghc <span class="at">--</span> <span class="at">-O2</span> average.hs <span class="kw">&amp;&amp;</span> <span class="ex">./average</span> +RTS <span class="at">-s</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ex">500000.5</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>          <span class="ex">98,784</span> bytes allocated in the heap</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>           <span class="ex">1,752</span> bytes copied during GC</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>          <span class="ex">42,856</span> bytes maximum residency <span class="er">(</span><span class="ex">1</span> sample<span class="er">(</span><span class="ex">s</span><span class="kw">))</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>          <span class="ex">26,776</span> bytes maximum slop</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>               <span class="ex">2</span> MB total memory in use <span class="er">(</span><span class="ex">0</span> MB lost due to fragmentation<span class="kw">)</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="ex">INIT</span>    time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="ex">MUT</span>     time    0.000s  <span class="er">(</span>  <span class="ex">0.002s</span> elapsed<span class="kw">)</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="ex">GC</span>      time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="ex">EXIT</span>    time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="ex">Total</span>   time    0.000s  <span class="er">(</span>  <span class="ex">0.003s</span> elapsed<span class="kw">)</span></span></code></pre></div>
<p>That’s only 3ms (from 9ms earlier), and allocations have completely vanished! Let’s look at the Core output:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>Main.main_<span class="op">$</span>s<span class="op">$</span>wgo [<span class="dt">Occ</span><span class="ot">=</span><span class="dt">LoopBreaker</span>]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">RunningTotal</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>[<span class="dt">GblId</span>, <span class="dt">Arity</span><span class="ot">=</span><span class="dv">3</span>, <span class="dt">Caf</span><span class="ot">=</span><span class="dt">NoCafRefs</span>, <span class="dt">Str</span><span class="op">=&lt;</span><span class="dt">L</span>,<span class="dt">U</span><span class="op">&gt;&lt;</span><span class="dt">L</span>,<span class="dt">U</span><span class="op">&gt;&lt;</span><span class="dt">S</span>,<span class="dv">1</span><span class="op">*</span><span class="dt">U</span><span class="op">&gt;</span>m]</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>Main.main_<span class="op">$</span>s<span class="op">$</span>wgo</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> \ (<span class="ot">sc_s4sk ::</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>      (<span class="ot">sc1_s4sj ::</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>      (<span class="ot">sc2_s4si ::</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span>) <span class="ot">-&gt;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> sc2_s4si <span class="kw">of</span> wild_X1h {</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        __DEFAULT <span class="ot">-&gt;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>          Main.main_<span class="op">$</span>s<span class="op">$</span>wgo</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            (<span class="op">GHC.Prim.+#</span> sc_s4sk <span class="dv">1</span><span class="op">#</span>)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>            (<span class="op">GHC.Prim.+#</span> sc1_s4sj wild_X1h)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>            (<span class="op">GHC.Prim.+#</span> wild_X1h <span class="dv">1</span><span class="op">#</span>);</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="dv">1000000</span><span class="op">#</span> <span class="ot">-&gt;</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Main.RunningTotal</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>            (<span class="dt">GHC.Types.I</span><span class="op">#</span> (<span class="op">GHC.Prim.+#</span> sc1_s4sj <span class="dv">1000000</span><span class="op">#</span>))</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>            (<span class="dt">GHC.Types.I</span><span class="op">#</span> (<span class="op">GHC.Prim.+#</span> sc_s4sk <span class="dv">1</span><span class="op">#</span>))</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>      }</span></code></pre></div>
<p>Amazing! No boxing happening at all.
That should be enough to reach C level performance, given a good compiler backend.
The takeaway is that using <code>foldl</code> is great as long as list fusion kicks in, but better err on the safe side and use the strict <code>foldl'</code> when we expect strictness anyway.</p>
<h2 id="summary">Summary</h2>
<p>This post tried to demonstrate how to debug strictness in the face of compiler optimizations to achieve minimal time and space footprints.
For that, we re-enacted how the compiler analyzes strictness properties of functions, to eventually pin down the subtle culprit in <code>printAverage</code>.
This kind of debugging is only possible through having a rough idea of strictness analysis and reading relevant GHC Core fragments and as such only makes sense with optimizations activated.</p>
<p>Of course, library writers have good reason to sprinkle bang patterns more liberally:
They need to guarantee that the maximum residency stays as low as possible for snappy <code>-O0</code> performance.
That’s what experimentally placing bang patterns at accumulators is good for:
Keeping the maximum residency at a minimum, so that time spent on GC is as low as possible.
It’s <em>not</em> good for teaching GHC what to unbox (e.g. reducing total allocations by more than a constant factor), as that doesn’t happen anyway at <code>-O0</code>.
And as soon as optimizations kick in, strictness analysis is mostly smart enough to figure things out by itself.</p>
<p>The next part of this series will implement a strictness analysis with the help of <a href="https://github.com/sgraf812/datafix"><code>datafix</code></a>, a new library of mine for writing static analyses.</p>
<p>Finally, some links for further reading:</p>
<ul>
<li><a href="http://blog.ezyang.com/2011/05/anatomy-of-a-thunk-leak/">Edward Yang: Anatomy of a thunk leak (2011)</a></li>
<li><a href="https://donsbot.wordpress.com/2008/05/06/write-haskell-as-fast-as-c-exploiting-strictness-laziness-and-recursion/">Don Stewart: Write Haskell as fast as C (2008)</a></li>
<li><a href="https://wiki.haskell.org/Performance/Strictness#Strictness_analysis">Haskell Wiki on Strictness (Analysis)</a></li>
</ul>
<p><b id="f1">1</b> That’s actually a bit simplified, as the real signature is <code>&lt;B,_&gt;&lt;B,_&gt;</code>, where <code>B</code> denotes a <em>hyperstrict</em> demand as explained on <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Demand">the wiki page</a>. <a href="#a1">↩︎</a></p>
</section>
<div id="disqus_thread"></div>
<script>
  /**
  *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
  *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
  /*
  var disqus_config = function () {
  this.page.url = fixpt.de/blog/2017-12-04-strictness-analysis-part-1.html;  // Replace PAGE_URL with your page's canonical URL variable
  this.page.identifier = /blog/2017-12-04-strictness-analysis-part-1.html; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
  };
  */
  (function () { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://fixpt.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>

</section>

  <!-- Copyright -->
      <ul class="copyright">
          <li><small>&copy; <a href="https://lanyon.getpoole.com">Lanyon Jekyll theme</a></small></li>
          <li><small>Adapted for Hakyll by Sebastian Graf</small></li>
          <li><small>Powered by <a href="http://jaspervdj.be/hakyll">Hakyll</a></small></li>
      </ul>
</div>

</body>

</html>
