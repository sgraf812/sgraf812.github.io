<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>fixpt</title>
    <link href="https://sgraf812.github.io//atom.xml" rel="self" />
    <link href="https://sgraf812.github.io/" />
    <id>https://sgraf812.github.io//atom.xml</id>
    <author>
        <name>Sebastian Graf</name>
        
        <email>sgraf1337@gmail.com</email>
        
    </author>
    <updated>2024-09-23T00:00:00Z</updated>
    <entry>
    <title>Total Denotational Semantics</title>
    <link href="https://sgraf812.github.io//blog/2024-09-23-total-denotational-semantics.html" />
    <id>https://sgraf812.github.io//blog/2024-09-23-total-denotational-semantics.html</id>
    <published>2024-09-23T00:00:00Z</published>
    <updated>2024-09-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Denotational semantics assign meaning to a program (e.g., in untyped lambda
calculus) by mapping the program into a self-contained domain model in some meta
language (e.g., Scott domains).
Traditionally, what is complicated about denotational semantics is not so much
the <em>function</em> that defines them; rather it is to find a sound mathematical
definition of the <em>semantic domain</em>, and a general methodology of doing so that
scales to recursive types and hence general recursion, global mutable state,
exceptions and concurrency<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p>In this post, I discuss a related issue: I argue that traditional Scott/Strachey
denotational semantics are <em>partial</em> (in a precise sense), which means that</p>
<ol type="1">
<li>It is impossible to give a faithful, executable encoding of such a semantics in a programming language, and</li>
<li>Internal details of the semantic domain inhibit high-level, equational reasonining about programs</li>
</ol>
<p>After exemplifying the problem, I will discuss <em>total</em> denotational semantics as
a viable alternative, and how to define one using guarded recursion.</p>
<!--more-->
<p>I do not claim that any of these considerations are novel or indisputable, but I
hope that they are helpful to some people who</p>
<ul>
<li>know how to read Haskell</li>
<li>like playing around with operational semantics and definitional interpreters</li>
<li>wonder how denotational semantics can be executed in a programming language</li>
<li>want to get excited about guarded recursion.</li>
</ul>
<p>I hope that this topic becomes more accessible to people with this background
due to a focus on <em>computation</em>.</p>
<p>I also hope that this post finds its way to a few semanticists who might provide
a useful angle or have answers to the conjectures in the later parts of this
post.</p>
<p>If you are in a rush and just want to see how a total denotational semantics
can be defined in Agda, have a look at
<a href="https://gist.github.com/sgraf812/b9c10d8386a5da7ffe014e9f1dd9bc83">this gist</a>.</p>
<hr />
<h1 id="syntax">Syntax</h1>
<p>We start by defining an AST type for lambda calculus:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Name</span> <span class="ot">=</span> <span class="dt">String</span>  <span class="co">-- x ∈ Name</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Exp</span>            <span class="co">-- e</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Name</span>        <span class="co">--   ::= x</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Exp</span> <span class="dt">Exp</span>     <span class="co">--    |  e1 e2</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Name</span> <span class="dt">Exp</span>    <span class="co">--    |  λx.e</span></span></code></pre></div>
<p>I will use the usual short-hand notation (BNF in comments above)</p>
<p><span class="math display">(λx.x)~(λy.y)</span></p>
<p>to parse as</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>) <span class="ot">`App`</span> (<span class="dt">Lam</span> <span class="st">&quot;y&quot;</span> (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>))</span></code></pre></div>
<p>and omit the parser that does this transformation.
I refer to <code>Exp</code> as the <em>object language</em> and to mathematics/Haskell as our
<em>meta language</em> in which we implement our semantics.</p>
<h1 id="call-by-name-semantics">Call-by-name Semantics</h1>
<p>Let us now define a denotational semantics for this language.
We will first do this in mathematics and later try and turn this definition into Haskell.</p>
<p>A denotational semantics is a function
<span class="math inline">\mathcal{I}\llbracket\cdot\rrbracket_{\cdot} : \mathsf{Exp} \to \mathsf{Map}(\mathsf{Name}, D) \to D</span>
such that <span class="math inline">\mathcal{I}\llbracket e\rrbracket_ρ</span> gives an expression <span class="math inline">e</span> a meaning, or <em>denotation</em>,
in terms of some semantic domain <span class="math inline">D</span>.
I pronounce <span class="math inline">\mathcal{I}\llbracket e\rrbracket_ρ</span> as “interpret <span class="math inline">e</span> in environment <span class="math inline">ρ</span>”.
The environment <span class="math inline">ρ</span> gives meaning to the free variables of <span class="math inline">e</span>,
by mapping each free variable to its denotation in <span class="math inline">D</span>, and
<span class="math inline">\mathsf{Map}(\mathsf{Name}, D)</span> is the type of finite maps (think: <code>Data.Map.Map</code>).
I will write
<span class="math inline">[x_1\mapsto d_1,...,x_n \mapsto d_n]</span> for a (possibly empty) finite map literal
that maps name <span class="math inline">x_i</span> to <span class="math inline">d_i</span>,
<span class="math inline">ρ[x\mapsto d]</span> for inserting the new mapping <span class="math inline">x \mapsto d</span> into the finite map
<span class="math inline">ρ</span>,
<span class="math inline">\mathsf{dom}(ρ)</span> for the keys that are present in <span class="math inline">ρ</span>, and
<span class="math inline">ρ(x)</span> for looking up name <span class="math inline">x</span> in <span class="math inline">ρ</span> (provided it is present).</p>
<p>With that disclaimer out of the way, here is the denotational semantics:</p>
<span class="math display">\begin{aligned}
\mathcal{I}\llbracket x\rrbracket_ρ &amp; = \begin{cases}
  ρ(x) &amp; x \in \mathsf{dom}(ρ) \\
  \bot &amp; \text{otherwise}
  \end{cases} \\
\mathcal{I}\llbracket λx.e\rrbracket_ρ &amp; = \mathsf{Fun}(f) \text{ where }f(d) = \mathcal{I}\llbracket e\rrbracket_{ρ[x \mapsto d]} \\
\mathcal{I}\llbracket e_1~e_2\rrbracket_ρ &amp; = \mathit{app}(\mathcal{I}\llbracket e_1\rrbracket_ρ, \mathcal{I}\llbracket e_2\rrbracket_ρ) \\
  \mathit{app}(d,a) &amp;= \begin{cases}
  f(a) &amp; \mathsf{Fun}(f) = d \\
  \bot &amp; \text{otherwise} \\
  \end{cases}
\end{aligned}</span>
<p>This is the standard by-name definition, but I have omitted an important detail.
I have not defined the semantic domain <span class="math inline">D</span> yet, so I shall do that now.</p>
<h1 id="scott-domain">Scott Domain</h1>
<p>To a first approximation, we can think of the Scott domain <span class="math inline">D</span> as the Haskell
data type</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">D</span>           <span class="co">-- d</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Fun</span> (<span class="dt">D</span> <span class="ot">-&gt;</span> <span class="dt">D</span>) <span class="co">--   ::= Fun (f ∈ D → D)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Bot</span>          <span class="co">--    |  ⊥</span></span></code></pre></div>
<p>Alas, this definition is not <em>well-founded</em>, and thus does not denote a proper
set (there is no set <span class="math inline">D</span> such that <span class="math inline">D</span> contains functions <span class="math inline">D \to D</span>).
To make it well-founded, we need to impose an approximation order <span class="math inline">⊑</span> on
<span class="math inline">D</span> in which <span class="math inline">\bot ⊏ \mathsf{Fun}(f)</span> and restrict the function type <span class="math inline">\to</span> to
functions that are monotone (<span class="math inline">\simeq</span> more defined input leads to more defined
output) and even continuous (<span class="math inline">\simeq</span> the output on infinite input is determined
by the finite prefixes of the input) in <span class="math inline">D</span>.
It is not important what <em>exactly</em> continuity means at this point, only that it
is impossible to impose this restriction in the type system of Haskell, let alone
enforce it as an invariant of <code>D</code>.</p>
<p>Henceforth, for every function <span class="math inline">f</span> that we stick into the <span class="math inline">\mathsf{Fun}</span>
constructor, we need to prove that it is continuous, including the function
<span class="math inline">f(d) = \mathcal{I}\llbracket e\rrbracket_{ρ[x \mapsto d]}</span> in the lambda case of the semantics.
That in turn means we need to prove that the interpretation function is
continuous as well, otherwise <span class="math inline">\mathcal{I}\llbracket\cdot\rrbracket</span> is not a well-defined
mathematical object.
One can see that this is quite tedious to prove by hand and in practice this
obligation is often hand-waved away, endangering the well-definedness of
any concept that builds on <span class="math inline">\mathcal{I}\llbracket\cdot\rrbracket</span>.</p>
<p>Let me support our understanding of <span class="math inline">\mathcal{I}\llbracket\cdot\rrbracket</span> with a few examples:</p>
<ul>
<li><span class="math inline">\mathcal{I}\llbracket λx.x\rrbracket_{[]} = \mathsf{Fun}(d \mapsto d)</span>.
Note that I write <span class="math inline">d \mapsto d</span> for a lambda expression in math, distinct from the <em>syntax</em> <span class="math inline">(λd.d)</span>.</li>
<li><span class="math inline">\mathcal{I}\llbracket(λx.x)~(λy.y)\rrbracket_{[]} = \mathit{app}(\mathsf{Fun}(d \mapsto d), \mathcal{I}\llbracket λy.y\rrbracket_{[]}) = \mathcal{I}\llbracket λy.y\rrbracket_{[]} = \mathsf{Fun}(d \mapsto d)</span>.</li>
<li><span class="math inline">\mathcal{I}\llbracket x~(λy.y)\rrbracket_{[]} = \mathit{app}(\mathcal{I}\llbracket x\rrbracket_{[]}, \mathcal{I}\llbracket λy.y\rrbracket_{[]}) = \mathit{app}(\bot, \mathcal{I}\llbracket λy.y\rrbracket_{[]}) = \bot</span>.
The bottom element <span class="math inline">\bot</span> is used to indicate a stuck program, in this case because variable <span class="math inline">x</span> is not “in scope” in the empty environment <span class="math inline">[]</span>.</li>
</ul>
<h1 id="a-partially-defined-denotational-interpreter">A <em>partially-defined</em> denotational interpreter</h1>
<p>Now consider the following attempt to make this semantics executable in Haskell:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">interp ::</span> <span class="dt">Map</span> <span class="dt">Name</span> <span class="dt">D</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">D</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>interp env (<span class="dt">Var</span> x) <span class="ot">=</span> <span class="kw">case</span> Map.lookup x env <span class="kw">of</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> d  <span class="ot">-&gt;</span> d</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Bot</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>interp env (<span class="dt">Lam</span> x e) <span class="ot">=</span> <span class="dt">Fun</span> (\d <span class="ot">-&gt;</span> interp (Map.insert x d env) e)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>interp env (<span class="dt">App</span> e1 e2) <span class="ot">=</span> <span class="kw">case</span> interp env e1 <span class="kw">of</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Fun</span> f <span class="ot">-&gt;</span> f (interp env e2)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  _     <span class="ot">-&gt;</span> <span class="dt">Bot</span></span></code></pre></div>
<p>I call <code>interp</code> a <em>denotational interpreter</em>, as suggested by
<a href="https://web.archive.org/web/20100216131108/https://matt.might.net/articles/writing-an-interpreter-substitution-denotational-big-step-small-step/">Matthew Might</a>.
The single most characteristic feature distinguishing it from a big-step style
definitional interpreter is the lambda case.
Note that the denotational interpreter recurses into the lambda body, sticking a
function of type <code>D -&gt; D</code> into the semantic <code>Fun</code> constructor, whereas a
big-step style interpreter would simply return the syntax <code>Lam x e</code>.</p>
<p>Surprisingly, the above translation of <span class="math inline">\mathcal{I}\llbracket\cdot\rrbracket</span> is <em>almost</em> correct!
It is correct whenever the object program terminates and
provides the same result as the denotational semantics for all three examples above.</p>
<p>However, when the object program does <em>not</em> terminate, the denotational
interpreter above does neither.
One example of such a program is <span class="math inline">\Omega := (λx.x~x)~(λx.x~x)</span>.
Running <code>interp</code> on the parse of this program simply loops forever, whereas the
denotational semantics <span class="math inline">\mathcal{I}\llbracket\cdot\rrbracket</span> assigns the meaning <span class="math inline">\bot</span> to
<span class="math inline">\Omega</span>, as common wisdom would have it.
Thus, when viewed as a mathematical function, <code>interp</code> above is only
partially-defined, or just <em>partial</em>.
This is in contrast to <span class="math inline">\mathcal{I}\llbracket\cdot\rrbracket</span>, which is a <em>total</em> mathematical
function, defined on every input.</p>
<p>(Doesn’t “<span class="math inline">\mathcal{I}\llbracket\cdot\rrbracket</span> is total” contradict the title of this post?
How can a function such as <span class="math inline">\mathcal{I}\llbracket\cdot\rrbracket</span> return <span class="math inline">\bot</span> but still be considered total?
Park these thoughts and read on.)</p>
<p><strong>It appears we cannot find a faithful executable definition of
<span class="math inline">\mathcal{I}\llbracket\cdot\rrbracket</span> in Haskell</strong>, one which encodes a <em>total</em> mathematical
function <span class="math inline">\mathcal{I}\llbracket\cdot\rrbracket</span>.
Which is a pity, because a definition in Haskell greatly helps in prototyping,
exploring and even formalising such semantics.</p>
<h1 id="divergence-is-hard-to-grasp-in-scott-domains">Divergence is hard to grasp in Scott domains</h1>
Actually, who says that <span class="math inline">\mathcal{I}\llbracket\Omega\rrbracket_{[]} = \bot</span>?
If we just calculate with the definition of <span class="math inline">\Omega</span>, we get
<span class="math display">\begin{aligned}
  \mathcal{I}\llbracket\Omega\rrbracket_{[]} &amp;= \mathcal{I}\llbracket(λx.x~x)~(λx.x~x)\rrbracket_{[]} \\
                      &amp;= \mathit{app}(\mathcal{I}\llbracket λx.x~x\rrbracket_{[]}, \mathcal{I}\llbracket λx. x~x\rrbracket_{[]}) \\
                      &amp;= \mathit{app}(\mathsf{Fun}(d \mapsto \mathcal{I}\llbracket x~x\rrbracket_{[x\mapsto d]}), \mathcal{I}\llbracket λx. x~x\rrbracket_{[]}) \\
                      &amp;= \mathcal{I}\llbracket x~x\rrbracket_{[x\mapsto \mathcal{I}\llbracket λx. x~x\rrbracket_{[]}]} \\
                      &amp;= \mathcal{I}\llbracket(λx.x~x)~(λx.x~x)\rrbracket_{[]} \\
                      &amp;= \mathcal{I}\llbracket\Omega\rrbracket_{[]} \\
\end{aligned}</span>
<p>A circular rewrite!
This chain of reasoning would hold true regardless of what value we would assign to <span class="math inline">\Omega</span>.
One way to prove that <span class="math inline">\mathcal{I}\llbracket\Omega\rrbracket_{[]} = \bot</span> is by generalising this statement to <span class="math inline">\mathrm{Y}(\mathit{id})</span>
and then understanding Example 3.6 of Pitts’
<a href="https://www.sciencedirect.com/science/article/pii/S0890540196900528">Relational Properties of Domain</a>.
Needless to say, even such an “obvious” semantic fact such as “<span class="math inline">\Omega</span>
diverges” does not hold by simple calculation and does not
even appear to be <a href="https://homepages.inf.ed.ac.uk/gdp/publications/TIM.pdf">true in some (inadequate) semantic domain
models</a>.
No wonder that it isn’t possible to compute it in Haskell either; after all,
computation is just a directed form of equational reasoning.</p>
<h1 id="total-denotational-interpreter">Total denotational interpreter</h1>
<p>Haskell is a lazy language.
As a Haskeller, I eat infinite lists for breakfast and enjoy it, because I know when
to stop <code>take</code>ing (🥁📀).
Can we somehow use laziness to encode diverging programs?</p>
<p>It turns out that, yes, we can!
We only need to adjust our semantic domain <code>D</code> as follows:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T</span> a <span class="ot">=</span> <span class="dt">Ret</span> <span class="op">!</span>a <span class="op">|</span> <span class="dt">Step</span> (<span class="dt">T</span> a)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Value</span> <span class="ot">=</span> <span class="dt">Fun</span> (<span class="dt">D</span> <span class="ot">-&gt;</span> <span class="dt">D</span>) <span class="op">|</span> <span class="dt">Stuck</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">D</span> <span class="ot">=</span> <span class="dt">T</span> <span class="dt">Value</span></span></code></pre></div>
<p>The coinductive <code>T</code> data type (for “trace”) is a
<a href="https://arxiv.org/abs/cs/0505037">classic</a>. It forms a monad as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">T</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="ot">=</span> <span class="dt">Ret</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Ret</span> a  <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> k a</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Step</span> d <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">Step</span> (d <span class="op">&gt;&gt;=</span> k)</span></code></pre></div>
<p>Note that <code>Step</code> is lazy, so we get diverging program “traces” as follows:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">diverge ::</span> <span class="dt">D</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>diverge <span class="ot">=</span> <span class="dt">Step</span> diverge</span></code></pre></div>
<p>It is pretty simple to run a <code>D</code> for a finite amount of time:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">takeD ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">T</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>takeD _ (<span class="dt">Ret</span> a)  <span class="ot">=</span> <span class="dt">Just</span> a</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>takeD <span class="dv">0</span> _        <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>takeD n (<span class="dt">Step</span> d) <span class="ot">=</span> takeD (n<span class="op">-</span><span class="dv">1</span>) d</span></code></pre></div>
<p>The use of <code>Step</code> is crucial to stratify diverging computations into an
infinite layering of finite computations, separated by <code>Step</code> constructors.
In other words: We use coinduction (well, Löb induction, but close enough) to
encode diverging programs.</p>
<p>It is sufficient to delay in a single place: right before we put a denotation
into the environment.
(A more common alternative in the literature is to delay in the variable case instead.)
The new definition becomes</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">denot ::</span> <span class="dt">Map</span> <span class="dt">Name</span> <span class="dt">D</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">D</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>denot env (<span class="dt">Var</span> x) <span class="ot">=</span> <span class="kw">case</span> Map.lookup x env <span class="kw">of</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> d  <span class="ot">-&gt;</span> d</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Stuck</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>denot env (<span class="dt">Lam</span> x e) <span class="ot">=</span> <span class="dt">Fun</span> (\d <span class="ot">-&gt;</span> denot (Map.insert x (<span class="dt">Step</span> d) env) e)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>denot env (<span class="dt">App</span> e1 e2) <span class="ot">=</span> denot env e1 <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Fun</span> f <span class="ot">-&gt;</span> f (denot env e2)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  _     <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">Stuck</span></span></code></pre></div>
<p>(A self-contained Haskell playground for <code>denot</code> can be found <a href="https://play.haskell.org/saved/haARY9UX">here</a>.)</p>
<p>We use monadic bind in the application case to sequence computations.
Note that if evaluation of <code>e1</code> diverges, the continuation of <code>&gt;&gt;=</code>
will never be called.</p>
<p>Using <code>takeD</code>, we may now execute a program for any number of <code>Step</code>s!
<code>denot</code> thus becomes a <em>total</em> function, defined by mixed induction (for <code>denot</code>)
and Löb induction (to define the lambda constructor).
Here are a two more examples:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- |</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; takeD 10000 $ denot Map.empty idid</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- Just (Fun ...)</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; denot Map.empty idid</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Step (Ret (Fun ...))</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="ot">idid ::</span> <span class="dt">Exp</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>idid <span class="ot">=</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>) <span class="ot">`App`</span> <span class="dt">Lam</span> <span class="st">&quot;y&quot;</span> (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- |</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; takeD 10000 $ denot Map.empty omega</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- Nothing</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="ot">omega ::</span> <span class="dt">Exp</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>omega <span class="ot">=</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span> <span class="ot">`App`</span> <span class="dt">Var</span> <span class="st">&quot;x&quot;</span>) <span class="ot">`App`</span> <span class="dt">Lam</span> <span class="st">&quot;y&quot;</span> (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span> <span class="ot">`App`</span> <span class="dt">Var</span> <span class="st">&quot;y&quot;</span>)</span></code></pre></div>
<p>If you want to see more of these, I encourage you to read Section 4 of
our work on <a href="https://arxiv.org/abs/2403.02778">abstracting denotational interpreters</a>.</p>
<h3 id="why-explicit-stuck">Why explicit <code>Stuck</code>?</h3>
<p>I renamed <code>Bot</code> to <code>Stuck</code> in the above definition of <code>Value</code> because that is
what its use now encodes: stuck programs terminate with a <code>Stuck</code> value that
works like an exception or <a href="https://homepages.inf.ed.ac.uk/wadler/papers/papers-we-love/milner-type-p%20olymorphism.pdf">Milner’s <span class="math inline">\textbf{wrong}</span>
value</a> (as in “well-typed programs cannot go wrong”).
This is observably distinct from the <code>diverge</code> denotation for diverging
programs.
I <em>could</em> have used <code>diverge</code> instead of <code>return Stuck</code>, however that would be
a bit misleading.
(As misleading as in the vanilla denotational semantics, where stuckness and
divergence are confused.)</p>
<h1 id="total-denotational-semantics">Total denotational semantics</h1>
<p>We can interpret the above definition of <code>D</code> straight as a domain equation of
(flat) Scott domains.
To do so, we need to adjoin a distinct bottom element <span class="math inline">\bot</span> again, with
the property that <span class="math inline">\bot ⊏ \mathsf{Fun}(f)</span>, <span class="math inline">\bot ⊏ \mathsf{Stuck}</span> and
<span class="math inline">\mathsf{Fun}(f)</span> incomparable to <span class="math inline">\mathsf{Stuck}</span>.</p>
<p>Here is the redefinition of <span class="math inline">\mathcal{I}\llbracket\cdot\rrbracket</span> in terms of the rejigged <span class="math inline">D</span>
(calling it <span class="math inline">\mathcal{D}\llbracket\cdot\rrbracket</span> for lack of a differentiating name):</p>
<span class="math display">\begin{aligned}
\mathcal{D}\llbracket x\rrbracket_ρ &amp; = \begin{cases}
  ρ(x) &amp; x \in \mathsf{dom}(ρ) \\
  \mathsf{Ret}(\mathsf{Stuck}) &amp; \text{otherwise}
  \end{cases} \\
\mathcal{D}\llbracket λx.e\rrbracket_ρ &amp; = \mathsf{Fun}(f) \text{ where }f(d) = \mathcal{D}\llbracket e\rrbracket_{ρ[x \mapsto \mathsf{Step}(d)]} \\
\mathcal{D}\llbracket e_1~e_2\rrbracket_ρ &amp; = \mathcal{D}\llbracket e_1\rrbracket_ρ &gt;\!\!&gt;\!\!=v \mapsto \mathit{app}(v, \mathcal{D}\llbracket e_2\rrbracket_ρ) \\
  \mathit{app}(v,a) &amp;= \begin{cases}
  f(a) &amp; \mathsf{Fun}(f) = v \\
  \mathsf{Ret}(\mathsf{Stuck}) &amp; \text{otherwise} \\
  \end{cases}
\end{aligned}</span>
<p>I omitted the definition of the bind operator <span class="math inline">&gt;\!\!&gt;\!\!=</span>, which is exactly as in Haskell.</p>
<p>It is reasonably simple to see by equational reasoning that <span class="math inline">\Omega</span> diverges:</p>
<span class="math display">\begin{aligned}
  \mathcal{D}\llbracket\Omega\rrbracket_{[]} &amp;= \mathcal{D}\llbracket(λx.x~x)~(λx.x~x)\rrbracket_{[]} \\
                      &amp;= \mathcal{D}\llbracket λx.x~x\rrbracket_{[]} &gt;\!\!&gt;\!\!=v \mapsto \mathit{app}(v, \mathcal{D}\llbracket λx. x~x\rrbracket_{[]}) \\
                      &amp;= \mathsf{Ret}(\mathsf{Fun}(d \mapsto \mathcal{D}\llbracket x~x\rrbracket_{[x\mapsto \mathsf{Step}(d)]})) &gt;\!\!&gt;\!\!=v \mapsto \mathit{app}(v, \mathcal{D}\llbracket λx. x~x\rrbracket_{[]}) \\
                      &amp;= \mathcal{D}\llbracket x~x\rrbracket_{[x\mapsto \mathsf{Step}(\mathcal{D}\llbracket λx. x~x\rrbracket_{[]})]} \\
                      &amp;= \mathcal{D}\llbracket x\rrbracket_{[x\mapsto \mathsf{Step}(\mathcal{D}\llbracket λx. x~x\rrbracket_{[]})]} &gt;\!\!&gt;\!\!=v \mapsto \mathit{app}(v, \mathcal{D}\llbracket x\rrbracket_{[x\mapsto \mathsf{Step}(\mathcal{D}\llbracket λx. x~x\rrbracket_{[]})]}) \\
                      &amp;= \mathsf{Step}(\mathcal{D}\llbracket λx. x~x\rrbracket_{[]}) &gt;\!\!&gt;\!\!=v \mapsto \mathit{app}(v, \mathsf{Step}(\mathcal{D}\llbracket λx. x~x\rrbracket_{[]})) \\
                      &amp;= \mathsf{Step}(\mathsf{Ret}(\mathsf{Fun}(d \mapsto \mathcal{D}\llbracket x~x\rrbracket_{[x\mapsto \mathsf{Step}(d)]}))) &gt;\!\!&gt;\!\!=v \mapsto \mathit{app}(v, \mathsf{Step}(\mathcal{D}\llbracket λx. x~x\rrbracket_{[]})) \\
                      &amp;= \mathsf{Step}(\mathcal{D}\llbracket x~x\rrbracket_{[x\mapsto \mathsf{Step}(\mathsf{Step}(\mathcal{D}\llbracket λx. x~x\rrbracket_{[]}))]}) \\
                      &amp;= ... \\
                      &amp;= \mathsf{Step}^n(\mathcal{D}\llbracket x~x\rrbracket_{[x\mapsto \mathsf{Step}^m(\mathcal{D}\llbracket λx. x~x\rrbracket_{[]})]}) \\
                      &amp;= ... \\
                      &amp;= \mathsf{Step}^ω = \mathit{diverge} \\
\end{aligned}</span>
<p>So that’s already nicer than with <span class="math inline">\mathcal{I}\llbracket\cdot\rrbracket</span>.
Another key difference to <span class="math inline">\mathcal{I}\llbracket\cdot\rrbracket</span> is that I believe <span class="math inline">\mathcal{D}\llbracket\cdot\rrbracket</span>
to be total, which implies that it maps total environments to total denotations<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.
(I’m <em>very optimistically</em> omitting a proof here, the novelty of which would
be unlikely. See the footnote.)</p>
<p>An element of a domain <span class="math inline">d</span> is <em>total</em><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> (or, <em>maximal</em>) if there are no other
elements <span class="math inline">d&#39;</span> above it, so <span class="math inline">d ⊑ d&#39; \implies d = d&#39;</span>.
An element <span class="math inline">d</span> is <em>partial</em> if there exists an element <span class="math inline">d&#39;</span> above it, <span class="math inline">d ⊏ d&#39;</span>.</p>
<p>Clearly, the bottom element <span class="math inline">\bot</span> is as partial as it gets (in a non-trivial
domain such as <span class="math inline">D</span>).
There are other <em>finite</em> partial elements such as <span class="math inline">\mathsf{Step}(\bot)</span>, but also
<em>infinite</em> partial elements such as <span class="math inline">(\bot,(\bot,(\bot,...)))</span> (if our <span class="math inline">D</span> had a
pair constructor).
There are <em>finite</em> total elements such as <span class="math inline">\mathsf{Ret}(\mathsf{Stuck})</span> and <em>infinite</em>
total elements such as <span class="math inline">\mathsf{Step}^ω</span> (corresponding to <code>diverge</code>).</p>
<p><em>In this precise sense</em>, the vanilla denotational semantics <span class="math inline">\mathcal{I}\llbracket e\rrbracket</span> is a
<em>partial</em> element of the monotone function space
<span class="math inline">\mathsf{Map}(\mathsf{Name}, D) \to D</span> (it returns <span class="math inline">\bot</span> in a couple of
situations) and <span class="math inline">\mathcal{D}\llbracket e\rrbracket</span> is a <em>total</em> element of the monotone function space
<span class="math inline">\mathsf{Map}(\mathsf{Name}, D) \to D</span>.
Note how this notion of partiality is different from partially of
a mathematical function: <span class="math inline">\mathcal{I}\llbracket e\rrbracket</span> is a partial <em>element</em>, but a total <em>function</em>.</p>
<h3 id="reasoning-and-computing-with-total-elements">Reasoning and computing with total elements</h3>
<p>The crucial insight is this: <strong>In programming languages, we can only really
reason equationally about and compute with <em>total</em> elements (finite or
infinite), but not so easily with <em>partial</em> ones</strong>, because that requires
reasoning in the actual formal <em>semantics</em> for the programming language (rather
than reasoning equationally on its <em>syntax</em>).</p>
<p>It is tiresome that in order to reason about diverging programs in our object
language <code>Exp</code>, we need to know whether a Haskell program diverges.
This means we need to know two formal semantics: a small one for <code>Exp</code> and a big
one for Haskell.</p>
<h3 id="total-elements-and-guarded-recursion-abstract-away-the-approximation-order">Total elements and guarded recursion abstract away the approximation order</h3>
<p>There is another advantage to such total denotational semantics:
Since total elements have no elements above them, the approximation order on
total elements is <em>discrete</em>, just like we are used from set theory.
That is, <span class="math inline">\mathsf{Ret}(\mathsf{Stuck})</span> is incomparable to
<span class="math inline">\mathsf{Step}(\mathsf{Ret}(\mathsf{Stuck}))</span> because both are total elements.
Thus, one can write total denotational semantics without thinking about
the approximation order, except in one specific case: encodings of recursion.</p>
<p>Our denotational semantics encodes recursion in the seemingly paradoxical
type of the <span class="math inline">\mathsf{Fun}</span> constructor, the field of which is a function taking
a <span class="math inline">D</span> as argument.
Such negative recursive occurrences are the bane of semanticists, but they
have developed a remedy: Guarded type systems.</p>
<h3 id="guarded-types-erase-to-continuous-definitions">Guarded types erase to continuous definitions</h3>
<p>In a guarded type system, one would declare that <span class="math inline">\mathsf{Fun}</span> has type
<span class="math inline">\blacktriangleright D \to D</span>, where <span class="math inline">\blacktriangleright</span> is an applicative functor
called the <em>later modality</em>, and the type checker would happily accept such
a type. The later modality can be thought of as a principled way to introduce a
lazy thunk. As such, we may change the type of <span class="math inline">\mathsf{Step}</span> to <span class="math inline">\blacktriangleright D \to
D</span>, encoding the lazy nature of <span class="math inline">\mathsf{Step}</span>.
Do note that the <span class="math inline">d</span> introduced in the lambda case of <span class="math inline">\mathcal{D}\llbracket\cdot\rrbracket</span> has type
<span class="math inline">\blacktriangleright D</span>, so it is important to give <span class="math inline">\mathsf{Step}</span> this delaying type in
order for the interpreter to be well-typed and total.</p>
<p>Et voilà, we have just proven that <span class="math inline">\mathcal{D}\llbracket\cdot\rrbracket</span> is well-defined and total
without (directly) appealing to any domain theory!</p>
<p>Presently, only few proof assistants have support for guarded types, but
Agda is one of them (albeit with rather rudimentary support).
<a href="https://gist.github.com/sgraf812/b9c10d8386a5da7ffe014e9f1dd9bc83">You can find an Agda encoding of <span class="math inline">\mathcal{D}\llbracket\cdot\rrbracket</span> in
this gist</a>.
A self-contained Haskell playground for <code>denot</code> can be found <a href="https://play.haskell.org/saved/haARY9UX">here</a>.</p>
<h1 id="conclusion">Conclusion</h1>
<p>This post was kind of a mixed bag of thoughts I had while working on our paper
<a href="https://arxiv.org/abs/2403.02778">Abstracting Denotational Interpreters</a>,
where I found it frustrating that I was lacking both the space and the words to
phrase this article into a proper motivation for the use of guarded type theory.
The ultimate goal of this post is to lure people who are familiar with
traditional denotational semantics into learning about total denotational
semantics and guarded type theory.</p>
<p>I sincerely believe that guarded type theory is the future for total, executable
reasoning about what today is often branded coinduction, since it is much more
applicable than mere coinduction but also different in subtle ways<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.
(For example, <code>D</code> could not be defined by coinduction because of the negative
recursion in <code>Fun</code>.)
Furthermore, it comes with decent (yet still incomplete) axiomatisations in
proof assistants.</p>
<p>I have glossed over <em>a lot</em> of related work in this post in order not to break the flow.
Apologies for that.
I suggest to have a look at the <a href="https://www.pls-lab.org/en/Guarded_recursion_(type_theory)">PLS lab page on guarded recursion</a>,
and perhaps start by reading Bob Atkey and Conor McBride’s classic <a href="https://bentnib.org/productive.pdf">Productive
Coprogramming with Guarded Recursion</a> (which
does not cover negative recursive occurrences yet).
One of the most exciting recent results in this area is a formal model for
<a href="https://arxiv.org/abs/2210.02169">impredicate guarded dependent type theory</a>
(phew!), which can serve as the justification for an axiomatisation in Rocq and
Lean, which has <a href="https://arxiv.org/abs/2308.02906">since been used</a> to define
the equivalent of the Iris higher-order concurrent separation logic framework.
The trace type <code>T</code> above is a much simplified version of a
<a href="https://arxiv.org/abs/2307.08514">guarded</a>
<a href="https://dl.acm.org/doi/10.1145/3371119">interaction tree</a>.
Definitional equality on (guarded or Scott) <code>D</code> is also <em>not</em> a very useful
program equivalence – you would still need to appeal to the coarser contextual
equivalence or a custom logical relation for proving interesting properties
about program rewrites.
My interest is in the context of abstract interpretation, where it is sufficient
to view equivalence modulo the abstraction function <span class="math inline">α</span>.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>The classic text demonstrating these issues is <a href="https://www.sciencedirect.com/science/article/pii/S0890540184710935">A Syntactic Approach to Type Soundness</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Incredibly smart semanticists such as Lars Birkedal, Jon Sterling and
others are continually improving the “internal language” (which I think
means “domain-specific language” to category theorists) for defining such
complex semantic domains; the subject of synthetic domain theory.
This <a href="https://www.youtube.com/watch?v=lLvweTSmR40">talk by Jon</a>
(with questions from 90 years old Dana Scott!) provides a lot of historic
context and can serve as a technical introduction as well.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>On the monotone function space <span class="math inline">D \to D</span>, a function <span class="math inline">f</span> is only total
when it is also maximally non-strict – that is, <span class="math inline">f(d)</span> must be the greatest
lower bound of its upper set in the range of <span class="math inline">f</span>.
More formally, <span class="math inline">f(d) = ⊓ \{ d&#39; \mid d&#39;∈ \mathsf{rng}(f) \land f(d) ⊑ d&#39; \}</span>.
For any function <span class="math inline">f</span> defined on total inputs, this can easily be achieved by
extending it to partial inputs via
<span class="math inline">f(d) := ⊓ \{ f(d&#39;) \mid d&#39; ∈ D \land d \text{ total} \land d ⊑ d&#39; \}</span>.
Note that any <span class="math inline">f&#39;</span> such that <span class="math inline">f ⊏ f&#39;</span> must overcommit for one input <span class="math inline">d_1</span>
(so <span class="math inline">f(d_1)⊏f&#39;(d_1)</span>), but then there must exist another <span class="math inline">d_2</span> such that
<span class="math inline">d_1 ⊏ d_2</span> for which <span class="math inline">f(d_2) \not⊑ f&#39;(d_2)</span>, otherwise <span class="math inline">f&#39;(d_1)</span> would
be a greater lower bound than <span class="math inline">f(d_1)</span>; contradiction.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>This is at least the terminology used in
<a href="https://arxiv.org/abs/1605.05858">Cartwright et al.</a>,
which I very much enjoyed.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>For a comparison of induction, coinduction and guarded
recursion, have a look at Section 16 of the
<a href="https://iris-project.org/tutorial-pdfs/iris-lecture-notes.pdf">Iris lecture notes</a>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>All About Strictness Analysis (part 2)</title>
    <link href="https://sgraf812.github.io//blog/2018-12-30-strictness-analysis-part-2.html" />
    <id>https://sgraf812.github.io//blog/2018-12-30-strictness-analysis-part-2.html</id>
    <published>2018-12-30T00:00:00Z</published>
    <updated>2018-12-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Welcome back! At the end of <a href="/blog/2017-12-04-strictness-analysis-part-1.html">part 1</a>
from December 4<sup id="a1"><a href="#f1">1</a></sup>, I made a promise to implement
a strictness analysis à la GHC with you.</p>
<p>Why would this be useful? In the last post, I argued that a rough
understanding of how strictness analysis works helps to debug and identify the
actual causes of missed unboxing opportunities and fix them with minimal effort.</p>
<p>So here it is, enjoy!</p>
<!--more-->
<hr />
<p>Since this is a literate markdown file, we need to get the boring preamble out of the way.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Strictness</span> <span class="kw">where</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (const)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Algebra.Lattice</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Merge.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span> (fromMaybe, mapMaybe)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Debug.Trace</span></span></code></pre></div>
<h2 id="syntax">Syntax</h2>
<p>Compared to GHC’s Core IR, we will have a simpler, untyped core calculus with
<code>let</code> bindings and if/then/else (instead of full-blown case expressions).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Name</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Name</span> <span class="dt">Expr</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Let</span> <span class="dt">Bind</span> <span class="dt">Expr</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">If</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Name</span> <span class="ot">=</span> <span class="dt">String</span> <span class="co">-- We assume names are unique!</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bind</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">NonRec</span> (<span class="dt">Name</span>, <span class="dt">Expr</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Rec</span> [(<span class="dt">Name</span>, <span class="dt">Expr</span>)]</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>Like in GHC, a program is just a list of top-level bindings. Also note that we
allow recursive bindings, which means the analysis will need to do
<em>fixed-point iteration</em> to reach a sound approximation of program semantics.</p>
<p>Next, we’ll define the <a href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice</a>
that will carry analysis information. Specifically, we will denote an
expression by its <em>strictness type</em>.</p>
<p>By the way, this blog post is so long because I tried to fit everything in one
literate Haskell file. Morally, this post should be split in two (or even three)
parts:
One discussing lattice ingredients and the other discussing how
to actually implement the analysis, just in case you felt
overwhelmed when looking at the scroll bar after scrolling the first time :).
I’ll remind you to take a break later on.</p>
<h2 id="lattice">Lattice</h2>
<p>For brevity, we will not include strictness on tuple components
(resp. record fields), because that would blow up this blog post too much.
But know that this approach extends straight-forwardly to records.</p>
<h3 id="strictness-signatures">Strictness signatures</h3>
<p>Without nested strictness on product types, is there even anything useful
to analyse for? Yes, there is! We can still record if a variable was evaluated
at all. There’s <code>const</code>, for example:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">const</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">const</span> a b <span class="ot">=</span> a</span></code></pre></div>
<p><code>const</code> is strict in its first argument and lazy in its second. That’s easy
to see by evaluating <code>const undefined 5</code> and <code>const 5 undefined</code>.
So, in the language of GHC’s demand signatures, we want to summarise <code>const</code> by
<code>&lt;S,_&gt;&lt;L,_&gt;</code> (usage demands elided). GHC will use this strictness signature at
every call site of <code>const</code> to approximate the strictness behavior of <code>const</code>
without having to repeatedly analyse its right-hand side during analysis.</p>
<h3 id="call-demands">Call demands</h3>
<p>Fair enough, but what about a function like <code>twice</code>?</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">twice ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>twice f x <span class="ot">=</span> f (f x)</span></code></pre></div>
<p>Since we don’t know anything about what strictness <code>f</code> puts on its argument,
we would summarise <code>twice</code> by the same signature as <code>const</code>.
But we really want a call like <code>twice (\x -&gt; x + n) m</code> to be strict in <code>n</code>!
Just knowing that we are <em>head</em>-strict in the lambda argument doesn’t cut it:
Evaluation will stop immediately since it’s already in weak-head normal form.
On the other hand, we can’t just interpret <code>S</code> as ‘strict on the return value’
(what does that even mean?) to unleash strictness on <code>n</code> within the lambda
body. Since <code>const</code> has the same signature, we would also mark <code>n</code> strict in
a call like <code>const (\x -&gt; x + m) 5</code>, which is incorrect:
<code>const (\x -&gt; undefined) 5 `seq` 42 == 42</code>.</p>
<p>There’s an unspoken assumption here: Strictness properties of some language
construct are always relative to an incoming <em>evaluation demand</em>, which is
head-strictness (the demand <code>seq</code> puts on its first argument) unless stated
otherwise. E.g., under the assumption of head-strictness, a call like
<code>const a b</code> is head-strict on <code>a</code> and lazy in <code>b</code>.</p>
<p>Note that <code>twice</code> differs from <code>const</code> in that it puts the <em>result</em>
of applying <code>f</code> to one argument under head-strictness. In GHC’s strictness
language, this corresponds to a <em>call demand</em> of <code>S(S)</code>. This is a strictly
stronger demand than <code>S</code>, the demand <code>const</code> puts on its first argument.</p>
<p>This has an important effect on our earlier <code>twice (\x -&gt; x + n) m</code> example.
Knowing that the lambda expression is put under strictness demand <code>S(S)</code>,
it is suddenly possible for the analysis to look inside the lambda
abstraction, paying with the outer call component to discharge the remaining
<code>S</code> demand on the lambda body. In this way, the analysis detects that the
whole expression is strict in <code>n</code>.</p>
<p>At the same time, analysing <code>const (\x -&gt; undefined) 5</code> assuming
head-strictness will only unleash a non-call demand <code>S</code> on the lambda,
which is not enough to meaningfully analyse its body under any other
strictness than <code>L</code>. This corresponds to our intuition that, relative
to a single evaluation (to head normal form) of our expression, the
lambda body may or may not be evaluated.</p>
<h3 id="free-variables">Free variables</h3>
<p>You may have noticed that we didn’t really define yet what it means for
a variable to be strict in some expression in which it occurs free.</p>
<p>Traditionally, a function <code>f</code> is strict in (one of) its parameter if
it preserves nontermination, i.e. <code>f undefined = undefined</code>.
There’s no way for the function to decide if its argument will blow up
when evaluated other than actually evaluating it, so it’s equivalent
to say that if <code>f</code> is strict, then (either <code>f = const undefined</code> or) it
evaluates its argument on every possible execution path.</p>
<p>How can we extend this to our intuitive notion of strictness in a variable
that occurs free in some expression? We can just capture that free
variable with a lambda and apply our original definition. So, when we talk
about the strictness of <code>n</code> as it demanded in <code>twice (\x -&gt; x + n) m</code>, we
are actually talking about strictness properties of the function
<code>\n -&gt; twice (\x -&gt; x + n) m</code>.</p>
<p>Our analysis will track free variables in an extra <em>environment</em>, mapping
<code>Name</code>s to the strictness demand they are put under.</p>
<p>Now might be a good time to take a short break (think part 2½). Or just keep
reading while the above discussion is still fresh in your mind.</p>
<h3 id="putting-the-lattice-together">Putting the lattice together</h3>
<p>Alright, so now we have everything in place to denote Haskell expressions
in terms of their strictness properties.</p>
<p>As discussed above, expressions, most prominently variables, can be put
under a certain <code>Strictness</code>, relative to an evaluation demand on their
surrounding expression:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Captures lower bounds on evaluation cardinality of some expression.</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- E.g.: Is this expression evaluated at least once? If so, what is the</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- maximum number of arguments it was surely applied to?</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Strictness</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Lazy</span>        <span class="co">-- ^ Evaluated lazily (possibly not evaluated at all)</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Strict</span> <span class="dt">Int</span>  <span class="co">-- ^ Evaluated strictly (at least once), called with n args</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">HyperStrict</span> <span class="co">-- ^ Fully evaluated, a call with maximum arity</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Eq</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Strictness</span> <span class="kw">where</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> <span class="dt">Lazy</span> <span class="ot">=</span> <span class="st">&quot;L&quot;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">Strict</span> <span class="dv">0</span>) <span class="ot">=</span> <span class="st">&quot;S&quot;</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">Strict</span> n) <span class="ot">=</span> <span class="st">&quot;S(&quot;</span> <span class="op">++</span> <span class="fu">show</span> (<span class="dt">Strict</span> (n<span class="op">-</span><span class="dv">1</span>)) <span class="op">++</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> <span class="dt">HyperStrict</span> <span class="ot">=</span> <span class="st">&quot;B&quot;</span></span></code></pre></div>
<p>The <code>Show</code> instance tries to adhere to GHC’s syntax. You can see how call
demands <code>S(_)</code> and regular strictness <code>S</code> could be elegantly unified in this
formulation. I snuck in another constructor, <code>HyperStrict</code>. You can think of
it as the strongest strictness possible. In our case, that corresponds to a call
with infinite arity.</p>
<p>Earlier, we were informally talking about how <code>S</code> is a <em>stronger</em> demand than
<code>L</code>. We can capture that meaning by providing an instance of <code>SemiJoinLattice</code>,
which consists of defining a <em>least upper bound</em> operator <code>\/</code> (also goes by
<em>join</em> or <em>supremum</em>):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">JoinSemiLattice</span> <span class="dt">Strictness</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lazy</span> \<span class="op">/</span> _ <span class="ot">=</span> <span class="dt">Lazy</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  _ \<span class="op">/</span> <span class="dt">Lazy</span> <span class="ot">=</span> <span class="dt">Lazy</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">HyperStrict</span> \<span class="op">/</span> s <span class="ot">=</span> s</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  s \<span class="op">/</span> <span class="dt">HyperStrict</span> <span class="ot">=</span> s</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Strict</span> n \<span class="op">/</span> <span class="dt">Strict</span> m <span class="ot">=</span> <span class="dt">Strict</span> (<span class="fu">min</span> n m)</span></code></pre></div>
On a total <code>Ord</code> like <code>Strictness</code>, this is just a fancy name for <code>max</code>.
“Hold on,”, I hear you complain, “I thought <code>HyperStrict</code> was the greatest element?!
This is all backwards!”.
<details>
<summary>
Answer with a quick detour on denotational semantics and static program analysis
</summary>
<p>Well, it’s customary in denotational semantics to
assume that the bottom element of the abstract lattice corresponds to
nontermination. So much, that Haskellers typically use the two terms
‘bottom’ and ‘nontermination’ interchangeably.</p>
<p>Now think of static program analysis, where every program point that
evaluates some expression will put semantic constraints on its denotation.
A conservative estimate of program semantics must be an upper bound to
the all constraints at that program point over every possible program path.</p>
<p>Consider the contrived example <code>if b then f 1 else f `seq` 42</code>;
each occurrence of <code>f</code> generates a semantic constraint on mutually exclusive
code paths. While the first occurrence is a call with one argument, i.e.
denoted by <code>Strict 1</code>, the second occurrence just puts <code>f</code> under a rather
weak <code>Strict 0</code> (i.e. head-strict) constraint.</p>
<p>What is the conservative estimate to strive for here? It’s the join of
<code>Strict 1</code> and <code>Strict 0</code>, so <code>Strict 0</code>! Generally speaking, as we
discover more and more constraints <code>f</code> is put under, its denotation will
climb up in the lattice. So, going up in the lattice means
‘more constrained’.</p>
<p>Note that there is also precedent of turning the lattice
upside down and denoting the least constrained element by top. This view is
adopted in the <a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">dragon book</a>,
for example.</p>
</details>
<p>Clearly, the least (or, bottom) element of the lattice wrt. to the above
join operator is <code>HyperStrict</code>. This justifies the following instance:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">BoundedJoinSemiLattice</span> <span class="dt">Strictness</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  bottom <span class="ot">=</span> <span class="dt">HyperStrict</span></span></code></pre></div>
<p>There’s some more boilerplate ahead for the dual semilattice, defining
the <em>greatest lower bound</em> or <em>meet</em> or <em>infimum</em> operator and an
associated top element:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MeetSemiLattice</span> <span class="dt">Strictness</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">HyperStrict</span> <span class="op">/</span>\ _ <span class="ot">=</span> <span class="dt">HyperStrict</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  _ <span class="op">/</span>\ <span class="dt">HyperStrict</span> <span class="ot">=</span> <span class="dt">HyperStrict</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lazy</span> <span class="op">/</span>\ s <span class="ot">=</span> s</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  s <span class="op">/</span>\ <span class="dt">Lazy</span> <span class="ot">=</span> s</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Strict</span> n <span class="op">/</span>\ <span class="dt">Strict</span> m <span class="ot">=</span> <span class="dt">Strict</span> (<span class="fu">max</span> n m)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">BoundedMeetSemiLattice</span> <span class="dt">Strictness</span> <span class="kw">where</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  top <span class="ot">=</span> <span class="dt">Lazy</span></span></code></pre></div>
<p>By the way, the syntactic resemblence to boolean operators is no
accident: In fact, the boolean algebra itself
<a href="https://en.wikipedia.org/wiki/Boolean_algebra_(structure)">is a very special kind of lattice</a>.</p>
<p>Where would this be useful? If you squint a little and call the meet
operator ‘both’ (for now), you can denote sequential composition with this.</p>
<p>Consider <code>if b `seq` True then b 42 else 1</code>. What strictness does
this place on <code>b</code>? Earlier, we used the join operator to combine
strictness from the <code>then</code> and <code>else</code> branch, corresponding to
<em>mutually exclusive</em> choices. That makes <code>Strict 1 \/ Lazy = Lazy</code>
for this example (note that <code>b</code> wasn’t used at all in the <code>else</code>
branch!). Now, there’s also an interesting condition to be analysed,
which puts <code>b</code> under <code>Strict 0</code> strictness. The condition will
certainly execute in the same evaluation as either branch.
Thus, we can pick the <em>stronger demand</em> of either the condition or
the join of the branches, which is <code>Strict 0 /\ Lazy = Strict 0</code>.</p>
<p>Great! That’s the bounded lattice for denoting variables. We can
extend this denotation to expressions by means of an environment
tracking the strictness demands on its free variables upon being
put under a certain (i.e. head-strict) evaluation demand:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A total map (a /function/) from @k@ to @v@ with useful</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- lattice instances.</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TotalMap</span> k v</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">TotalMap</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> def ::</span> <span class="op">!</span>v</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> points ::</span> <span class="op">!</span>(<span class="dt">Map</span> k v)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="ot">lookupTM ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">TotalMap</span> k v <span class="ot">-&gt;</span> v</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="ot">insertTM ::</span> (<span class="dt">Ord</span> k, <span class="dt">Eq</span> v) <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">TotalMap</span> k v <span class="ot">-&gt;</span> <span class="dt">TotalMap</span> k v</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="ot">deleteTM ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">TotalMap</span> k v <span class="ot">-&gt;</span> <span class="dt">TotalMap</span> k v</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">StrEnv</span> <span class="ot">=</span> <span class="dt">TotalMap</span> <span class="dt">Name</span> <span class="dt">Strictness</span></span></code></pre></div>
Such a <code>StrEnv</code> is just a total map from <code>Name</code>s to <code>Strictness</code>.
We can just use its point-wise lattice instance and be done with it.
<details>
<summary>
Boring implementations and lattice instances
</summary>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>lookupTM n env <span class="ot">=</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  fromMaybe (def env) (Map.lookup n (points env))</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>insertTM n s env</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> s <span class="op">==</span> def env <span class="ot">=</span> env { points <span class="ot">=</span> Map.delete n (points env) }</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>    <span class="ot">=</span> env { points <span class="ot">=</span> Map.insert n s (points env) }</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>deleteTM n env <span class="ot">=</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  env { points <span class="ot">=</span> Map.delete n (points env) }</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="ot">joinOrMeet ::</span> (<span class="dt">Eq</span> v, <span class="dt">Ord</span> k) <span class="ot">=&gt;</span> (v <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> v) <span class="ot">-&gt;</span> <span class="dt">TotalMap</span> k v <span class="ot">-&gt;</span> <span class="dt">TotalMap</span> k v <span class="ot">-&gt;</span> <span class="dt">TotalMap</span> k v</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>joinOrMeet (<span class="op">/</span>\<span class="op">/</span>) (<span class="dt">TotalMap</span> def1 ps1) (<span class="dt">TotalMap</span> def2 ps2) <span class="ot">=</span> <span class="dt">TotalMap</span> def ps</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    def <span class="ot">=</span> def1 <span class="op">/</span>\<span class="op">/</span> def2</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    filterMaybe f a <span class="ot">=</span> a <span class="op">&lt;$</span> guard (f a)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    mmc f <span class="ot">=</span> Map.mapMaybeMissing (\_ <span class="ot">-&gt;</span> filterMaybe (<span class="op">/=</span> def) <span class="op">.</span> f)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    zmmc f <span class="ot">=</span> Map.zipWithMaybeMatched (\_ a <span class="ot">-&gt;</span> filterMaybe (<span class="op">/=</span> def) <span class="op">.</span> f a)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    ps <span class="ot">=</span> Map.merge (mmc (<span class="op">/</span>\<span class="op">/</span> def2)) (mmc (def1 <span class="op">/</span>\<span class="op">/</span>)) (zmmc (<span class="op">/</span>\<span class="op">/</span>)) ps1 ps2</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Ord</span> k, <span class="dt">Eq</span> v, <span class="dt">JoinSemiLattice</span> v) <span class="ot">=&gt;</span> <span class="dt">JoinSemiLattice</span> (<span class="dt">TotalMap</span> k v) <span class="kw">where</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>  (\<span class="op">/</span>) <span class="ot">=</span> joinOrMeet (\<span class="op">/</span>)</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Ord</span> k, <span class="dt">Eq</span> v, <span class="dt">BoundedJoinSemiLattice</span> v) <span class="ot">=&gt;</span> <span class="dt">BoundedJoinSemiLattice</span> (<span class="dt">TotalMap</span> k v) <span class="kw">where</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>  bottom <span class="ot">=</span> <span class="dt">TotalMap</span> bottom Map.empty</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Ord</span> k, <span class="dt">Eq</span> v, <span class="dt">MeetSemiLattice</span> v) <span class="ot">=&gt;</span> <span class="dt">MeetSemiLattice</span> (<span class="dt">TotalMap</span> k v) <span class="kw">where</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>  (<span class="op">/</span>\) <span class="ot">=</span> joinOrMeet (<span class="op">/</span>\)</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Ord</span> k, <span class="dt">Eq</span> v, <span class="dt">BoundedMeetSemiLattice</span> v) <span class="ot">=&gt;</span> <span class="dt">BoundedMeetSemiLattice</span> (<span class="dt">TotalMap</span> k v) <span class="kw">where</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>  top <span class="ot">=</span> <span class="dt">TotalMap</span> top Map.empty</span></code></pre></div>
</details>
<p>This is enough vocabulary to analyse simple expressions. But, as
discussed above, we need argument strictness to express how a
function or lambda uses its arguments. So here we go:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ArgStr</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">BottomArgStr</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TopArgStr</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">ConsArgStr</span> <span class="dt">Strictness</span> <span class="dt">ArgStr</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Eq</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">ArgStr</span> <span class="kw">where</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> <span class="dt">BottomArgStr</span> <span class="ot">=</span> <span class="st">&quot;B,B..&quot;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> <span class="dt">TopArgStr</span> <span class="ot">=</span> <span class="st">&quot;L,L..&quot;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">ConsArgStr</span> s argStr) <span class="ot">=</span> <span class="fu">show</span> s <span class="op">++</span> <span class="st">&quot;,&quot;</span> <span class="op">++</span> <span class="fu">show</span> argStr</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">JoinSemiLattice</span> <span class="dt">ArgStr</span> <span class="kw">where</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">BottomArgStr</span> \<span class="op">/</span> s <span class="ot">=</span> s</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>  s \<span class="op">/</span> <span class="dt">BottomArgStr</span> <span class="ot">=</span> s</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TopArgStr</span> \<span class="op">/</span> _ <span class="ot">=</span> <span class="dt">TopArgStr</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>  _ \<span class="op">/</span> <span class="dt">TopArgStr</span> <span class="ot">=</span> <span class="dt">TopArgStr</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">ConsArgStr</span> s1 a1) \<span class="op">/</span> (<span class="dt">ConsArgStr</span> s2 a2) <span class="ot">=</span> <span class="dt">ConsArgStr</span> (s1 \<span class="op">/</span> s2) (a1 \<span class="op">/</span> a2)</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">BoundedJoinSemiLattice</span> <span class="dt">ArgStr</span> <span class="kw">where</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>  bottom <span class="ot">=</span> <span class="dt">BottomArgStr</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- | This instance doesn&#39;t make a lot of sense semantically,</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a><span class="co">-- but it&#39;s the dual to the &#39;JoinSemiLattice&#39; instance.</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- We mostly need this for &#39;top&#39;.</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MeetSemiLattice</span> <span class="dt">ArgStr</span> <span class="kw">where</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>  <span class="dt">BottomArgStr</span> <span class="op">/</span>\ _ <span class="ot">=</span> <span class="dt">BottomArgStr</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>  _ <span class="op">/</span>\ <span class="dt">BottomArgStr</span> <span class="ot">=</span> <span class="dt">BottomArgStr</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TopArgStr</span> <span class="op">/</span>\ s <span class="ot">=</span> s</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>  s <span class="op">/</span>\ <span class="dt">TopArgStr</span> <span class="ot">=</span> s</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">ConsArgStr</span> s1 a1) <span class="op">/</span>\ (<span class="dt">ConsArgStr</span> s2 a2) <span class="ot">=</span> <span class="dt">ConsArgStr</span> (s1 <span class="op">/</span>\ s2) (a1 <span class="op">/</span>\ a2)</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">BoundedMeetSemiLattice</span> <span class="dt">ArgStr</span> <span class="kw">where</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>  top <span class="ot">=</span> <span class="dt">TopArgStr</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a><span class="ot">consArgStr ::</span> <span class="dt">Strictness</span> <span class="ot">-&gt;</span> <span class="dt">ArgStr</span> <span class="ot">-&gt;</span> <span class="dt">ArgStr</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>consArgStr <span class="dt">Lazy</span> <span class="dt">TopArgStr</span>           <span class="ot">=</span> <span class="dt">TopArgStr</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>consArgStr <span class="dt">HyperStrict</span> <span class="dt">BottomArgStr</span> <span class="ot">=</span> <span class="dt">BottomArgStr</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>consArgStr s a                      <span class="ot">=</span> <span class="dt">ConsArgStr</span> s a</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a><span class="ot">unconsArgStr ::</span> <span class="dt">ArgStr</span> <span class="ot">-&gt;</span> (<span class="dt">Strictness</span>, <span class="dt">ArgStr</span>)</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>unconsArgStr <span class="dt">BottomArgStr</span>     <span class="ot">=</span> (bottom, <span class="dt">BottomArgStr</span>)</span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>unconsArgStr <span class="dt">TopArgStr</span>        <span class="ot">=</span> (top, <span class="dt">TopArgStr</span>)</span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>unconsArgStr (<span class="dt">ConsArgStr</span> s a) <span class="ot">=</span> (s, a)</span></code></pre></div>
<p>Within this framework, a function like <code>error</code> would have strictness signature
<code>ConsArgStr Lazy BottomArgStr</code>, expressing the fact that when it’s applied to
one argument, it will not necessarily evaluate that argument, but will lead to
an exception (which is the same as divergence, semantically speaking) if the call
expression would be evaluated. On the other hand, a lambda like <code>\f -&gt; f a</code> would
be denoted by an argument strictness like <code>ConsArgStr (Strict 1) TopArgStr</code>.
What about <code>a</code>? That’s tracked in the strictness environment, the other major
component of an expression’s strictness type:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">StrType</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">StrType</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> fvs  ::</span> <span class="op">!</span><span class="dt">StrEnv</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> args ::</span> <span class="op">!</span><span class="dt">ArgStr</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">JoinSemiLattice</span> <span class="dt">StrType</span> <span class="kw">where</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">StrType</span> fvs1 args1 \<span class="op">/</span> <span class="dt">StrType</span> fvs2 args2 <span class="ot">=</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">StrType</span> (fvs1 \<span class="op">/</span> fvs2) (args1 \<span class="op">/</span> args2)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">BoundedJoinSemiLattice</span> <span class="dt">StrType</span> <span class="kw">where</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>  bottom <span class="ot">=</span> <span class="dt">StrType</span> bottom bottom</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- | This instance doesn&#39;t make a lot of sense semantically,</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- but it&#39;s the dual to the &#39;JoinSemiLattice&#39; instance.</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- We mostly need this for &#39;top&#39;.</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MeetSemiLattice</span> <span class="dt">StrType</span> <span class="kw">where</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">StrType</span> fvs1 args1 <span class="op">/</span>\ <span class="dt">StrType</span> fvs2 args2 <span class="ot">=</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">StrType</span> (fvs1 <span class="op">/</span>\ fvs2) (args1 <span class="op">/</span>\ args2)</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">BoundedMeetSemiLattice</span> <span class="dt">StrType</span> <span class="kw">where</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>  top <span class="ot">=</span> <span class="dt">StrType</span> top top</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- | This will be used instead of &#39;(/\)&#39; for sequential composition.</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a><span class="co">-- It&#39;s right biased, meaning that it will return the</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a><span class="co">-- argument strictness of the right argument.</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a><span class="ot">bothStrType ::</span> <span class="dt">StrType</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>bothStrType (<span class="dt">StrType</span> fvs1 _) (<span class="dt">StrType</span> fvs2 args2) <span class="ot">=</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>  <span class="dt">StrType</span> (fvs1 <span class="op">/</span>\ fvs2) args2</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a><span class="ot">unitStrType ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Strictness</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>unitStrType n s <span class="ot">=</span> <span class="dt">StrType</span> (insertTM n s top) top</span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a><span class="ot">overFVs ::</span> (<span class="dt">StrEnv</span> <span class="ot">-&gt;</span> (a, <span class="dt">StrEnv</span>)) <span class="ot">-&gt;</span> <span class="dt">StrType</span> <span class="ot">-&gt;</span> (a, <span class="dt">StrType</span>)</span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>overFVs f ty <span class="ot">=</span></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (a, fvs&#39;) <span class="ot">=</span> f (fvs ty)</span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> (a, ty { fvs <span class="ot">=</span> fvs&#39; })</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a><span class="ot">peelFV ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span> <span class="ot">-&gt;</span> (<span class="dt">Strictness</span>, <span class="dt">StrType</span>)</span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>peelFV n <span class="ot">=</span> overFVs <span class="op">$</span> \fvs <span class="ot">-&gt;</span></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>  (lookupTM n fvs, deleteTM n fvs)</span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a><span class="ot">modifyFVs ::</span> (<span class="dt">StrEnv</span> <span class="ot">-&gt;</span> <span class="dt">StrEnv</span>) <span class="ot">-&gt;</span> <span class="dt">StrType</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>modifyFVs f <span class="ot">=</span> <span class="fu">snd</span> <span class="op">.</span> overFVs (\a <span class="ot">-&gt;</span> ((), f a))</span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a><span class="ot">deleteFV ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span></span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>deleteFV <span class="ot">=</span> modifyFVs <span class="op">.</span> deleteTM</span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a><span class="ot">overArgs ::</span> (<span class="dt">ArgStr</span> <span class="ot">-&gt;</span> (a, <span class="dt">ArgStr</span>)) <span class="ot">-&gt;</span> <span class="dt">StrType</span> <span class="ot">-&gt;</span> (a, <span class="dt">StrType</span>)</span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a>overArgs f ty <span class="ot">=</span></span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (a, args&#39;) <span class="ot">=</span> f (args ty)</span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> (a, ty { args <span class="ot">=</span> args&#39; })</span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true" tabindex="-1"></a><span class="ot">modifyArgs ::</span> (<span class="dt">ArgStr</span> <span class="ot">-&gt;</span> <span class="dt">ArgStr</span>) <span class="ot">-&gt;</span> <span class="dt">StrType</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span></span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true" tabindex="-1"></a>modifyArgs f <span class="ot">=</span> <span class="fu">snd</span> <span class="op">.</span> overArgs (\a <span class="ot">-&gt;</span> ((), f a))</span></code></pre></div>
<p>So, strictness environment for free variables, argument strictness for
arguments. A last ingredient is an environment that will carry
strictness signatures for functions we analysed before:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Arity</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">SigEnv</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">Name</span> (<span class="dt">Arity</span>, <span class="dt">StrType</span>)</span></code></pre></div>
<p>Any strictness signature is only valid when a certain number of incoming
arguments is reached. We store this <em>arity</em> (as in unary, binary, etc.)
alongside the strictness signature. Generally, assuming a higher arity can lead
to more precise strictness signatures, but applies to less call sites.
GHC will only analyse each function once and assume an incoming strictness
demand correspond to manifest arity of the function, e.g. the number of
top-level lambdas in the RHS of the function’s definition.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Counts the number of top-level lambdas.</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="ot">manifestArity ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Arity</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>manifestArity (<span class="dt">Lam</span> _ e) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> manifestArity e</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>manifestArity _ <span class="ot">=</span> <span class="dv">0</span></span></code></pre></div>
<p>That’s it for the lattice! Have a break and enter part 3…</p>
<h2 id="analysis">Analysis</h2>
<p>Let’s define the main analysis function for our core calculus:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">analyse ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span></span></code></pre></div>
<p>We analyse an expression to find out what strictness it puts its free
variables under if put under head-demand:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>analyse <span class="ot">=</span> expr Map.empty <span class="dv">0</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="ot">expr ::</span> <span class="dt">SigEnv</span> <span class="ot">-&gt;</span> <span class="dt">Arity</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">StrType</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>expr sigs incomingArity <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">If</span> b t e <span class="ot">-&gt;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    expr sigs <span class="dv">0</span> b <span class="ot">`bothStrType`</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>      (expr sigs incomingArity t \<span class="op">/</span> expr sigs incomingArity e)</span></code></pre></div>
<p><code>analyse</code> immediately delegates to a more complicated auxiliary function.
We’ll first look at the <code>If</code> case here: <code>If</code> will sequentially combine
(‘both’) the analysis results from analysing the condition under incoming
arity 0 with the result of joining the analysis results of both branches
with the arity that came in from outside. Very much what we would expect
after our reasoning above!</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">App</span> f a <span class="ot">-&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>      fTy <span class="ot">=</span> expr sigs (incomingArity <span class="op">+</span> <span class="dv">1</span>) f</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>      (argStr, fTy&#39;) <span class="ot">=</span> overArgs unconsArgStr fTy</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>      aTy <span class="ot">=</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> argStr <span class="kw">of</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- bottom = unbounded arity, only possibly constrained by the type</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- of `a`, which we don&#39;t look at here.</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>          <span class="dt">HyperStrict</span> <span class="ot">-&gt;</span> expr sigs <span class="fu">maxBound</span> a</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Strict</span> n <span class="ot">-&gt;</span> expr sigs n a</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- `a` is possibly not evaluated at all, so nothing to see there</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Lazy</span> <span class="ot">-&gt;</span> top</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> aTy <span class="ot">`bothStrType`</span> fTy&#39;</span></code></pre></div>
<p>In an application, the head will be analysed with an incremented incoming arity,
while the argument is only evaluated if it was put under a strict context.
This is determined by examining the strictness type of analysing <code>f</code>.</p>
<p>The resulting types are sequentially combined (‘both’).
Note that <code>bothStrType</code> is right-biased and will pass on the argument
strictness from <code>fTy'</code>, which is exactly what we want. This will get clearer
once we examine the variable case.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lam</span> n body <span class="ot">-&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>      bodyTy</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> incomingArity <span class="op">&lt;=</span> <span class="dv">0</span> <span class="ot">=</span> top</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> expr sigs (incomingArity <span class="op">-</span> <span class="dv">1</span>) body</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- normally, we would also store the strictness of n in the syntax tree</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- or in a separate map, but we are only interested in free variables</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- here for simplicity.</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>      (str, bodyTy&#39;) <span class="ot">=</span> peelFV n bodyTy</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> modifyArgs (consArgStr str) bodyTy&#39;</span></code></pre></div>
<p>This is somewhat dual to the application case. Lambdas ‘eat’ arity, so when we run
out of arity to feed it, we are not allowed to use analysis results from the body.
The only sensible thing to assume is a <code>top</code> strictness type in that case.</p>
<p>The call to <code>peelFV</code> will abstract out the strictness on the argument and we finally
cons that strictness onto the argument strictness of the lambda body’s strictness
type. Consider what happens for an expression like <code>\f -&gt; f a</code>: The lambda body
puts its free variable <code>f</code> under strictness <code>Strict 1</code>, so when we abstract over
<code>f</code>, we remove it from <code>fvs</code> and cons it to the lambdas argument strictness instead.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Var</span> n <span class="ot">-&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> sig <span class="ot">=</span> fromMaybe top <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>          (arity, sig) <span class="ot">&lt;-</span> Map.lookup n sigs</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>          guard (arity <span class="op">&lt;=</span> incomingArity)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>          <span class="fu">pure</span> sig</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> bothStrType (unitStrType n (<span class="dt">Strict</span> incomingArity)) sig</span></code></pre></div>
<p>The variable case will try to look up a signature in the signature environment,
check for its compatibility with the incoming arity and fall back to <code>top</code>
if any of the guards fail. The resulting signature is combined with
a unit strictness type just for this particular call site.</p>
<p>A call to <code>const</code> with two arguments (so <code>arity == 2</code> when we hit the variable)
would pass the arity check and return the <code>&lt;S,_&gt;&lt;L,_&gt;</code> (resp. <code>S,L,..</code> in our
syntax) signature from above. The application case at any call site would then
unleash the proper argument strictness on the concrete argument expressions.</p>
<p>What remains is handling let-bindings. Let’s look at the non-recursive case first:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Let</span> (<span class="dt">NonRec</span> (name, rhs)) body <span class="ot">-&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>      arity <span class="ot">=</span> manifestArity rhs</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>      rhsTy <span class="ot">=</span> expr sigs arity rhs</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>      sigs&#39; <span class="ot">=</span> Map.insert name (arity, rhsTy) sigs</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>      bodyTy <span class="ot">=</span> expr sigs&#39; incomingArity body</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Normally, we would store how &#39;name&#39; was used in the body somewhere</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>      bodyTy&#39; <span class="ot">=</span> deleteFV name bodyTy</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> bodyTy&#39;</span></code></pre></div>
<p>Even without recursion, this is quite involved. First, we analyse the RHS
assuming a call with manifest arity. The resulting strictness type is then inserted
into the signature environment for the appropriate arity. The body is analysed
with this new signature environment. As <code>rhsTy</code> is unleashed at call sites through
the <code>Var</code> case, there is no need to <code>bothStrType</code> the resulting <code>bodyTy'</code> with
<code>rhsTy</code> (and would even be wrong, consider the case where the binding is not used
strictly).</p>
<p>Fair enough, now onto the recursive case. Typically, this is the case where static
analyses
<a href="https://en.wikipedia.org/wiki/Rice%27s_theorem">have to yield approximate results in order to stay decidable</a>.
Typically, this is achieved through calculating the least fixed-point of the
transfer function wrt. to the analysis lattice. Strictness analysis is no
different in that regard:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Let</span> (<span class="dt">Rec</span> binds) body <span class="ot">-&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>      sigs&#39; <span class="ot">=</span> fixBinds sigs binds</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>      bodyTy <span class="ot">=</span> expr sigs&#39; incomingArity body</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>      bodyTy&#39; <span class="ot">=</span> <span class="fu">foldr</span> deleteFV bodyTy (<span class="fu">map</span> <span class="fu">fst</span> binds)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> bodyTy&#39;</span></code></pre></div>
<p>That wasn’t so hard! It seems that a few more functions were abstracted into
<code>fixBinds</code>, which is responsible for finding a set of sound strictness
signatures for the binding group. Let’s see what else hides in <code>fixBinds</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fixBinds ::</span> <span class="dt">SigEnv</span> <span class="ot">-&gt;</span> [(<span class="dt">Name</span>, <span class="dt">Expr</span>)] <span class="ot">-&gt;</span> <span class="dt">SigEnv</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>fixBinds sigs binds <span class="ot">=</span> toSigEnv stableTypes</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    names ::</span> [<span class="dt">Name</span>]</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    names <span class="ot">=</span> <span class="fu">map</span> <span class="fu">fst</span> binds</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    toSigEnv ::</span> [(<span class="dt">Arity</span>, <span class="dt">StrType</span>)] <span class="ot">-&gt;</span> <span class="dt">SigEnv</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    toSigEnv <span class="ot">=</span> <span class="fu">foldr</span> (\(n, ty) <span class="ot">-&gt;</span> Map.insert n ty) sigs <span class="op">.</span> <span class="fu">zip</span> names</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    fromSigEnv ::</span> <span class="dt">SigEnv</span> <span class="ot">-&gt;</span> [(<span class="dt">Arity</span>, <span class="dt">StrType</span>)]</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    fromSigEnv sigs <span class="ot">=</span> mapMaybe (<span class="fu">flip</span> Map.lookup sigs) names</span></code></pre></div>
<p>We’ll convert back and forth between the <code>SigEnv</code> representation and the list
of points of the <code>SigEnv</code> that are actually subject to change. <code>toSigEnv</code>
converts the points of the current binding group into a proper <code>SigEnv</code> by
adding them to the incoming <code>SigEnv</code>, which contains strictness signatures
for outer bindings.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">    stableTypes ::</span> [(<span class="dt">Arity</span>, <span class="dt">StrType</span>)]</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    stableTypes <span class="ot">=</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>      <span class="fu">fst</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span> <span class="fu">head</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span> <span class="fu">filter</span> (<span class="fu">uncurry</span> (<span class="op">==</span>))</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> <span class="fu">zip</span> approximations (<span class="fu">tail</span> approximations)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="ot">    start ::</span> [(<span class="dt">Arity</span>, <span class="dt">StrType</span>)]</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    start <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">const</span> (<span class="dv">0</span>, bottom)) binds</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="ot">    approximations ::</span> [[(<span class="dt">Arity</span>, <span class="dt">StrType</span>)]]</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    approximations <span class="ot">=</span> <span class="fu">iterate</span> iter start</span></code></pre></div>
<p>This part is concerned with finding the fixed-point of <code>iter</code>, beginning with an
optimistic approximation <code>start</code>, where all bindings are approximated by <code>bottom</code>.
We have found a fixed-point as soon as <code>approximations</code> becomes stable. This is
detected by <code>stableTypes</code>, which we converted into the result of <code>fixBinds</code> above.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">    iter ::</span> [(<span class="dt">Arity</span>, <span class="dt">StrType</span>)] <span class="ot">-&gt;</span> [(<span class="dt">Arity</span>, <span class="dt">StrType</span>)]</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    iter tys <span class="ot">=</span> fromSigEnv (<span class="fu">foldr</span> iterBind (toSigEnv tys) binds)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    iterBind (name, rhs) sigs&#39; <span class="ot">=</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>        arity <span class="ot">=</span> manifestArity rhs</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>        rhsTy <span class="ot">=</span> expr sigs&#39; (manifestArity rhs) rhs</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>        rhsTy&#39; <span class="ot">=</span> <span class="fu">foldr</span> deleteFV rhsTy names</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span> Map.insert name (arity, rhsTy&#39;) sigs&#39;</span></code></pre></div>
<p>Aha, so <code>iterBind</code> is where the logic from the non-recursive case ended up!
The other functions were just a big build up to set up fixed-point iteration.
We compute iterated approximations of the signature environment until we hit
the fixed-point, at which point we have a sound approximation of program
semantics.</p>
<h2 id="test-drive">Test-drive</h2>
<p>Phew! That’s it. Let’s put our function to work.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>a, b, c,<span class="ot"> f ::</span> <span class="dt">Expr</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>(a<span class="op">:</span>b<span class="op">:</span>c<span class="op">:</span>_<span class="op">:</span>_<span class="op">:</span>f<span class="op">:</span>_) <span class="ot">=</span> <span class="fu">map</span> (<span class="dt">Var</span> <span class="op">.</span> (<span class="op">:</span>[])) [<span class="ch">&#39;a&#39;</span><span class="op">..</span>]</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="ot">exprs ::</span> [<span class="dt">Expr</span>]</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>exprs <span class="ot">=</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  [ <span class="dt">If</span> a b c</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">If</span> a b b</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">If</span> a (<span class="dt">App</span> f b) (<span class="dt">App</span> f c)</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">App</span> (<span class="dt">Lam</span> <span class="st">&quot;b&quot;</span> b) a</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">Let</span> (<span class="dt">NonRec</span> (<span class="st">&quot;f&quot;</span>, <span class="dt">Lam</span> <span class="st">&quot;b&quot;</span> b)) (<span class="dt">App</span> f a)</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">Let</span> (<span class="dt">Rec</span> [(<span class="st">&quot;f&quot;</span>, <span class="dt">Lam</span> <span class="st">&quot;b&quot;</span> (<span class="dt">App</span> f b))]) (<span class="dt">App</span> f a)</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">Let</span> (<span class="dt">Rec</span> [(<span class="st">&quot;f&quot;</span>, <span class="dt">Lam</span> <span class="st">&quot;b&quot;</span> (<span class="dt">If</span> b c (<span class="dt">App</span> f b)))]) (<span class="dt">App</span> f a)</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> forM_ exprs <span class="op">$</span> \e <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> e</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (analyse e)</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;&quot;</span></span></code></pre></div>
<p>This is its output:</p>
<pre class="unknown"><code>If (Var &quot;a&quot;) (Var &quot;b&quot;) (Var &quot;c&quot;)
StrType {fvs = TotalMap {def = L, points = fromList [(&quot;a&quot;,S)]}, args = L,L..}

If (Var &quot;a&quot;) (Var &quot;b&quot;) (Var &quot;b&quot;)
StrType {fvs = TotalMap {def = L, points = fromList [(&quot;a&quot;,S),(&quot;b&quot;,S)]}, args = L,L..}

If (Var &quot;a&quot;) (App (Var &quot;f&quot;) (Var &quot;b&quot;)) (App (Var &quot;f&quot;) (Var &quot;c&quot;))
StrType {fvs = TotalMap {def = L, points = fromList [(&quot;a&quot;,S),(&quot;f&quot;,S(S))]}, args = L,L..}

App (Lam &quot;b&quot; (Var &quot;b&quot;)) (Var &quot;a&quot;)
StrType {fvs = TotalMap {def = L, points = fromList [(&quot;a&quot;,S)]}, args = L,L..}

Let (NonRec (&quot;f&quot;,Lam &quot;b&quot; (Var &quot;b&quot;))) (App (Var &quot;f&quot;) (Var &quot;a&quot;))
StrType {fvs = TotalMap {def = L, points = fromList [(&quot;a&quot;,S)]}, args = L,L..}

Let (Rec [(&quot;f&quot;,Lam &quot;b&quot; (App (Var &quot;f&quot;) (Var &quot;b&quot;)))]) (App (Var &quot;f&quot;) (Var &quot;a&quot;))
StrType {fvs = TotalMap {def = B, points = fromList []}, args = B,B..}

Let (Rec [(&quot;f&quot;,Lam &quot;b&quot; (If (Var &quot;b&quot;) (Var &quot;c&quot;) (App (Var &quot;f&quot;) (Var &quot;b&quot;))))]) (App (Var &quot;f&quot;) (Var &quot;a&quot;))
StrType {fvs = TotalMap {def = L, points = fromList [(&quot;a&quot;,S),(&quot;c&quot;,S)]}, args = L,L..}</code></pre>
<p>The first two test-cases are concerned with testing the <code>If</code> case.
The next two expressions test <code>App</code>lications and <code>Lam</code>das, most importantly
correct handling of incoming arity. Note how this correctly infers that <code>a</code>
was used strictly in the fourth example. What follows is a non-recursive
let-binding, basically doing the same as the fourth expression.</p>
<p>The last two expressions show-case what this simple analysis is able to infer.
First, there’s a nonterminating <code>let f b = f b in f a</code> which is correctly
denoted by <code>bot</code>tom. This already hints that our analysis is able carry out some
inductive reasoning.
The last example then analyses <code>let f b = if b then c else f b in f a</code> to find
out that both <code>a</code> and <code>c</code> are used strictly. Cool!</p>
<h2 id="conclusion">Conclusion</h2>
<p>We defined a projection-based strictness analysis in the style of GHC that
actually finds out useful things about our code!</p>
<p>I hope that in doing so, you got a feeling about what GHC can and cannot derive
about the performance critical code you write. Specifically, looking back at
the problem in <a href="/blog/2017-12-04-strictness-analysis-part-1.html">part 1</a>, you
should now be able to see why we needed a bang in <code>printAverage</code> and how that
enables GHC to infer that the accumulator can be completely unboxed. This is
just by mechanically following the analysis rules above!</p>
<p>Granted, there are many details in which GHC’s demand analyser (which does
strictness analysis) differs from the analysis above:</p>
<ul>
<li>Local, non-recursive thunk bindings have a different analysis rule than
functions</li>
<li>We ignore product demands like <code>S(LS(S))</code> for simplicity, but it’s
straight-forward to extend</li>
<li>Various hacks and special cases that you can ignore in 95% of all cases</li>
</ul>
<p>If you want to know more about these details, read the following papers:</p>
<ul>
<li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/demand.pdf">Complete, but dated report on the demand analyser</a>. This is probably the best paper for having an overview of what GHC does today in 95% of all cases.</li>
<li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2017/03/demand-jfp-draft.pdf">Incomplete, but recent report on the demand analyser</a></li>
<li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2014/01/cardinality-popl14.pdf">Complete, recent report on usage analysis (dual to strictness) within the demand analyser</a></li>
</ul>
<p>I agree if you say that the documentation story is a little insatisfying.
Anyway, the ultimate reference is always the code of
<a href="https://gitlab.haskell.org/ghc/ghc/blob/master/compiler/stranal/DmdAnal.hs">the demand analyser within GHC itself</a>.</p>
<p>If/when I come around to it, I can finally pitch you my
<a href="https://hackage.haskell.org/package/datafix"><code>datafix</code> library</a> for computing
fixed-points like we just did in a more principled way.
So stay stuned for part 4 :)</p>
<p><b id="f1">1</b> … 2017<a href="#a1">↩︎</a></p>]]></summary>
</entry>
<entry>
    <title>All About Strictness Analysis (part 1)</title>
    <link href="https://sgraf812.github.io//blog/2017-12-04-strictness-analysis-part-1.html" />
    <id>https://sgraf812.github.io//blog/2017-12-04-strictness-analysis-part-1.html</id>
    <published>2017-12-04T00:00:00Z</published>
    <updated>2017-12-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Non-strict languages like Haskell often require the programmer to reason about strictness to achieve good performance.
A while ago, Michael Snoyman wrote a <a href="https://www.fpcomplete.com/blog/2017/09/all-about-strictness">blog post</a> about this, giving an introduction on the matter as well as an overview over the tools at our disposal.</p>
<p>In this post, I want to offer another, more surgical approach to plugging space leaks that works hand in hand with optimizations carried out by the compiler.</p>
<!--more-->
<h2 id="the-setting">The Setting</h2>
<p>Michael Snoyman fixed problems due to laziness by making ample use of strictness annotations.
This is the right approach when you run into space leaks in debug builds.
It’s also good practice for library writers, where you cannot anticipate usage patterns, so the least you could do is force strict parameters as early as possible.</p>
<p>Running example in Snoyman’s blog post were variants of the following program computing the average of a list of <code>Int</code>egers:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RunningTotal</span> <span class="ot">=</span> <span class="dt">RunningTotal</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> sum   ::</span> <span class="dt">Int</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> count ::</span> <span class="dt">Int</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ot">printAverage ::</span> <span class="dt">RunningTotal</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>printAverage (<span class="dt">RunningTotal</span> <span class="fu">sum</span> count)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> count <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Need at least one value!&quot;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">print</span> (<span class="fu">fromIntegral</span> <span class="fu">sum</span> <span class="op">/</span> <span class="fu">fromIntegral</span><span class="ot"> count ::</span> <span class="dt">Double</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="ot">printListAverage ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>printListAverage <span class="ot">=</span> go (<span class="dt">RunningTotal</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    go rt [] <span class="ot">=</span> printAverage rt</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    go (<span class="dt">RunningTotal</span> <span class="fu">sum</span> count) (x<span class="op">:</span>xs) <span class="ot">=</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>      go (<span class="dt">RunningTotal</span> (<span class="fu">sum</span> <span class="op">+</span> x) (count <span class="op">+</span> <span class="dv">1</span>)) xs</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> printListAverage [<span class="dv">1</span><span class="op">..</span><span class="dv">1000000</span>]</span></code></pre></div>
<p>In absence of any optimization, this is quite hungry for memory:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack <span class="at">--resolver</span><span class="op">=</span>nightly-2017-12-01 ghc <span class="at">--</span> <span class="at">-O0</span> average.hs <span class="kw">&amp;&amp;</span> <span class="ex">./average</span> +RTS <span class="at">-s</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ex">500000.5</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>     <span class="ex">258,650,856</span> bytes allocated in the heap</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>     <span class="ex">348,098,952</span> bytes copied during GC</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>      <span class="ex">74,388,992</span> bytes maximum residency <span class="er">(</span><span class="ex">9</span> sample<span class="er">(</span><span class="ex">s</span><span class="kw">))</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>         <span class="ex">599,832</span> bytes maximum slop</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>             <span class="ex">179</span> MB total memory in use <span class="er">(</span><span class="ex">0</span> MB lost due to fragmentation<span class="kw">)</span></span></code></pre></div>
<p>Significant numbers are roughly 250MB in allocations over the course of execution, as well as a maximum working set of 74MB.
I’m currently on stackage <code>nightly-2017-12-01</code> (GHC 8.2.2) on a Windows box, which might explain differences in measurement.</p>
<p>The post goes on to annotate the accumulating parameter of <code>go</code> with bang patterns:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RunningTotal</span> <span class="ot">=</span> <span class="dt">RunningTotal</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> sum   ::</span> <span class="dt">Int</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> count ::</span> <span class="dt">Int</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="ot">printAverage ::</span> <span class="dt">RunningTotal</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>printAverage (<span class="dt">RunningTotal</span> <span class="fu">sum</span> count)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> count <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Need at least one value!&quot;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">print</span> (<span class="fu">fromIntegral</span> <span class="fu">sum</span> <span class="op">/</span> <span class="fu">fromIntegral</span><span class="ot"> count ::</span> <span class="dt">Double</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="ot">printListAverage ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>printListAverage <span class="ot">=</span> go (<span class="dt">RunningTotal</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    go rt [] <span class="ot">=</span> printAverage rt</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    go (<span class="dt">RunningTotal</span> <span class="op">!</span><span class="fu">sum</span> <span class="op">!</span>count) (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="co">-- only this line changed</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>      go (<span class="dt">RunningTotal</span> (<span class="fu">sum</span> <span class="op">+</span> x) (count <span class="op">+</span> <span class="dv">1</span>)) xs</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> printListAverage [<span class="dv">1</span><span class="op">..</span><span class="dv">1000000</span>]</span></code></pre></div>
<p>This has a great effect on maximum residency:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack <span class="at">--resolver</span><span class="op">=</span>nightly-2017-12-01 ghc <span class="at">--</span> <span class="at">-O0</span> average.hs <span class="kw">&amp;&amp;</span> <span class="ex">./average</span> +RTS <span class="at">-s</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ex">500000.5</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>     <span class="ex">192,099,048</span> bytes allocated in the heap</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>         <span class="ex">245,416</span> bytes copied during GC</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>          <span class="ex">42,856</span> bytes maximum residency <span class="er">(</span><span class="ex">2</span> sample<span class="er">(</span><span class="ex">s</span><span class="kw">))</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>          <span class="ex">30,872</span> bytes maximum slop</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>               <span class="ex">2</span> MB total memory in use <span class="er">(</span><span class="ex">0</span> MB lost due to fragmentation<span class="kw">)</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="ex">INIT</span>    time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="ex">MUT</span>     time    0.031s  <span class="er">(</span>  <span class="ex">0.029s</span> elapsed<span class="kw">)</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="ex">GC</span>      time    0.000s  <span class="er">(</span>  <span class="ex">0.001s</span> elapsed<span class="kw">)</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="ex">EXIT</span>    time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="ex">Total</span>   time    0.031s  <span class="er">(</span>  <span class="ex">0.030s</span> elapsed<span class="kw">)</span></span></code></pre></div>
<p>The program now executes in constant residency, which, in the presence of garbage collection, guarantees constant space usage! Nonetheless, we still produce a lot of garbage (190MB) and need 30ms to arrive at that result.</p>
<h2 id="optimizations">Optimizations</h2>
<p>Compare that to what happens when we compile with optimizations on:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack <span class="at">--resolver</span><span class="op">=</span>nightly-2017-12-01 ghc <span class="at">--</span> <span class="at">-O2</span> average.hs <span class="kw">&amp;&amp;</span> <span class="ex">./average</span> +RTS <span class="at">-s</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ex">500000.5</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>     <span class="ex">128,098,744</span> bytes allocated in the heap</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>          <span class="ex">13,800</span> bytes copied during GC</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>          <span class="ex">42,856</span> bytes maximum residency <span class="er">(</span><span class="ex">1</span> sample<span class="er">(</span><span class="ex">s</span><span class="kw">))</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>          <span class="ex">30,872</span> bytes maximum slop</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>               <span class="ex">2</span> MB total memory in use <span class="er">(</span><span class="ex">0</span> MB lost due to fragmentation<span class="kw">)</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="ex">INIT</span>    time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="ex">MUT</span>     time    0.016s  <span class="er">(</span>  <span class="ex">0.014s</span> elapsed<span class="kw">)</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="ex">GC</span>      time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="ex">EXIT</span>    time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="ex">Total</span>   time    0.016s  <span class="er">(</span>  <span class="ex">0.015s</span> elapsed<span class="kw">)</span></span></code></pre></div>
<p>Optimizations chipped off a huge amount of total allocations and also cut execution time in half.</p>
<p>How can we improve on this? By deleting the two bangs we inserted earlier (simply for dramatic effect) and placing one in the pattern of <code>printAverage</code> instead:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RunningTotal</span> <span class="ot">=</span> <span class="dt">RunningTotal</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> sum   ::</span> <span class="dt">Int</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> count ::</span> <span class="dt">Int</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="ot">printAverage ::</span> <span class="dt">RunningTotal</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>printAverage (<span class="dt">RunningTotal</span> <span class="op">!</span><span class="fu">sum</span> count) <span class="co">-- New bang here</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> count <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Need at least one value!&quot;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">print</span> (<span class="fu">fromIntegral</span> <span class="fu">sum</span> <span class="op">/</span> <span class="fu">fromIntegral</span><span class="ot"> count ::</span> <span class="dt">Double</span>)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="ot">printListAverage ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>printListAverage <span class="ot">=</span> go (<span class="dt">RunningTotal</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    go rt [] <span class="ot">=</span> printAverage rt</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    go (<span class="dt">RunningTotal</span> <span class="fu">sum</span> count) (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="co">-- No more bangs here</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>      go (<span class="dt">RunningTotal</span> (<span class="fu">sum</span> <span class="op">+</span> x) (count <span class="op">+</span> <span class="dv">1</span>)) xs</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> printListAverage [<span class="dv">1</span><span class="op">..</span><span class="dv">1000000</span>]</span></code></pre></div>
<p>Compile and execute this in old fashion with optimizations on:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack <span class="at">--resolver</span><span class="op">=</span>nightly-2017-12-01 ghc <span class="at">--</span> <span class="at">-O2</span> average.hs <span class="kw">&amp;&amp;</span> <span class="ex">./average</span> +RTS <span class="at">-s</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ex">500000.5</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>      <span class="ex">80,098,744</span> bytes allocated in the heap</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>           <span class="ex">5,864</span> bytes copied during GC</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>          <span class="ex">42,856</span> bytes maximum residency <span class="er">(</span><span class="ex">1</span> sample<span class="er">(</span><span class="ex">s</span><span class="kw">))</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>          <span class="ex">30,872</span> bytes maximum slop</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>               <span class="ex">2</span> MB total memory in use <span class="er">(</span><span class="ex">0</span> MB lost due to fragmentation<span class="kw">)</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="ex">INIT</span>    time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="ex">MUT</span>     time    0.000s  <span class="er">(</span>  <span class="ex">0.009s</span> elapsed<span class="kw">)</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="ex">GC</span>      time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="ex">EXIT</span>    time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="ex">Total</span>   time    0.000s  <span class="er">(</span>  <span class="ex">0.009s</span> elapsed<span class="kw">)</span></span></code></pre></div>
<p>Another huge chunk of allocations is gone and execution time reduced by at least 30% again! What just happened?</p>
<h2 id="the-compiler-can-reason-about-strictness">The compiler can reason about strictness</h2>
<p>The strictness analysis of GHC (which is integrated in its <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Demand">Demand Analyzer</a>, a behemoth that interleaves three different analyses) is quite capable.
Without any intervention it would have recognized that the recursive <code>go</code> is strict not only in the <code>RunningTotal</code> constructor, but also in its <code>count</code> field.
Perhaps surprisingly, it would find the <code>sum</code> field <em>not</em> to be evaluated strictly.</p>
<p>That’s due to a subtlety in the definition of <code>printAverage</code>:
Note that in the <code>count == 0</code> error case that <code>sum</code> isn’t evaluated at all!
And indeed, <code>printAverage (RunningTotal undefined 0)</code> will print the expected error message instead of crashing due to <code>undefined</code>, which is the very definition of being lazy in <code>sum</code>.
This extends to a call like <code>go (RunningTotal undefined 0) []</code>, so GHC can’t just unbox the <code>sum</code> field even if the recursive case of <code>go</code> is annotated.
So placing a bang in <code>printAverage</code> makes sense after all:
There isn’t much utility in allowing calls like <code>printAverage (RunningTotal undefined 0)</code>.</p>
<p>What I found quite essential to pin down the cause of this performance regression is a combination of looking at the GHC Core output as well as reproduce what strictness analysis found out.
Let’s start with a crash course on a simple strictness analysis similar to GHC’s.</p>
<p>In order to be scalable, GHC summarizes each function by a <em>demand signature</em> (consult the <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Demand">GHC wiki page</a> for details), part of which relates how a single call evaluates its arguments and free variables.
The signature for <code>printAverage</code> for example looks like <code>&lt;S(LS(S)),_&gt;</code> (we elide usage demands, suggested by the <code>_</code> wildcard), which reads as:
When <code>printAverage</code> is called with one argument, it will evaluate that argument strictly (the <code>RunningTotal</code> box), as well as unpack the boxed <code>Int</code> in its second field (<code>count</code>) strictly, while being <code>L</code>azy in the first field (<code>sum</code>).</p>
<p>It’s not hard to see how to arrive at that signature:
We (and the compiler) assume a call with one argument (ignoring intricacies regarding <code>IO</code>), and see that the first branch is lazy in <code>sum</code>, while the second is strict in both.
Prior to that, the <code>RunningTotal</code> is unpacked (evaluated!) and <code>count</code> is compared to 0, which also entails unpacking the <code>Int</code> constructor to get at the unboxed <code>Int#</code>.
Combined, <code>RunningTotal</code>s <code>count</code> field is put under strictness <code>S(S)</code> (the unpacked <code>Int#</code> in the box is evaluated strictly), while <code>sum</code> is put under strictness <code>L</code>, resulting in said strictness demand of <code>S(LS(S))</code> on the <code>RunningTotal</code> argument.</p>
<p>Non-recursive functions are trivial to analyze and are inlined most of the time anyway.
What about a recursive function, such as <code>go</code>?
Let’s see what GHC found out by dumping the module’s Core IR after the strictness analyzer has been run with <code>-ddump-stranal</code> (simplified):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> stack <span class="co">--resolver=nightly-2017-12-01 ghc -- -O2 average.hs -ddump-stranal -fforce-recomp</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span>             ( average<span class="op">.</span>hs, average<span class="op">.</span>o )</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">====================</span> <span class="dt">Demand</span> analysis <span class="op">====================</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="ot">go ::</span> <span class="dt">RunningTotal</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>[<span class="op">...</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a> <span class="dt">Arity</span><span class="ot">=</span><span class="dv">2</span>,</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a> <span class="dt">Str</span><span class="op">=&lt;</span><span class="dt">S</span>(<span class="dt">LS</span>(<span class="dt">S</span>)),<span class="dv">1</span><span class="op">*</span><span class="dt">U</span>(<span class="dv">1</span><span class="op">*</span><span class="dt">U</span>(<span class="dt">U</span>),<span class="dv">1</span><span class="op">*</span><span class="dt">U</span>(<span class="dt">U</span>))<span class="op">&gt;&lt;</span><span class="dt">S</span>,<span class="dv">1</span><span class="op">*</span><span class="dt">U</span><span class="op">&gt;</span>,</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a> <span class="op">...</span>]</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>go</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> \ (<span class="ot">rt ::</span> <span class="dt">RunningTotal</span>)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>      (<span class="ot">xs ::</span> [<span class="dt">Int</span>]) <span class="ot">-&gt;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> xs <span class="kw">of</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        [] <span class="ot">-&gt;</span> <span class="co">-- inlining of `printAverage rt`</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> x xs <span class="ot">-&gt;</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>          <span class="kw">case</span> rt <span class="kw">of</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">RunningTotal</span> <span class="fu">sum</span> count <span class="ot">-&gt;</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>              go</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>                (<span class="dt">Main.RunningTotal</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>                  (<span class="op">GHC.Num.$</span>fNumInt_<span class="op">$</span>c<span class="op">+</span> <span class="fu">sum</span> x)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>                  (<span class="kw">case</span> count <span class="kw">of</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">GHC.Types.I</span><span class="op">#</span> count<span class="op">#</span> <span class="ot">-&gt;</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">GHC.Types.I</span><span class="op">#</span> (<span class="op">GHC.Prim.+#</span> count<span class="op">#</span> <span class="dv">1</span><span class="op">#</span>)))</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>                xs</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a><span class="op">====================</span> <span class="dt">Demand</span> analysis <span class="op">====================</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>Note that there are multiple runs of the demand analyzer, but we’ll focus on the first run for now, before any of the strictness information was exploited by transformations downstream.</p>
<p>Crucial is the demand signature assigned to <code>go</code>, which is available as the <code>Str</code> attribute (usage demands elided again): <code>&lt;S(LS(S)),_&gt;&lt;S,_&gt;</code>.
This is just as expected.
The first <code>RunningTotal</code> argument is unpacked all the time (in the <code>[]</code> case, that’s done by <code>printAverage</code>), but its <code>sum</code> field is only evaluated lazily because the error case in <code>printAverage</code> isn’t strict in it, so by induction, <code>go</code> is neither.
The second argument is the list of integers to average, which we immediately match on, so naturally its outer constructor is used strictly.</p>
<p>It’s one thing for humans to reason like this, but how do we teach this to a compiler?
The key here is inductive reasoning: Under the assumption that <code>go</code> has the above demand signature to be unleashed at recursive call sites, we can indeed verify <code>go</code> has this signature.</p>
<p>For that, the compiler initially assumes the most <em>optimistic</em> demand signature possible for <code>go</code>, which corresponds to <code>&lt;S(S(S)S(S)),_&gt;&lt;S,_&gt;</code><sup id="a1"><a href="#f1">1</a></sup>, the demand a <code>deepseq</code> would put on the arguments.
Assuming this for the recursive case, we can see that the newly constructed <code>RunningTotal (sum + x) (count + 1)</code> is <code>deepseq</code>ed immediately, which translates into a strictness of <code>S(S)</code> on both fields of the <code>RunningTotal</code> argument.</p>
<p>In the base case, however, the call to <code>printAverage</code> causes the <code>count</code> field to only be evaluated lazily.
That’s enough for the whole case match to be lazy in <code>count</code>, so the computed strictness signature is <code>&lt;S(LS(S)),_&gt;&lt;S,_&gt;</code>.
Now the compiler has to reiterate analysis of <code>go</code>, because the assumed signature was too optimistic.
Fortunately, under the assumption of <code>&lt;S(LS(S)),_&gt;&lt;S,_&gt;</code> for the recursive call, we arrive at exactly the same signature.
Analysis has reached a <em>fixed-point</em> in its endeavour to find a conservative approximation for the strictness properties of <code>go</code> at runtime.</p>
<h2 id="all-boxes-must-go">All boxes must go</h2>
<p>Having a basic understanding of how strictness analysis works, we see that <code>printAverage</code> is the reason why <code>sum</code> isn’t unboxed.
As soon as we add the bang in the relevant position, as I foreshadowed above, we arrive at the following, simplified Core output:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> stack <span class="co">--resolver=nightly-2017-12-01 ghc -- -O2 average.hs -ddump-simpl -fforce-recomp</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>Main.main_<span class="op">$</span>s<span class="op">$</span>wgo</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>[<span class="dt">GblId</span>, <span class="dt">Arity</span><span class="ot">=</span><span class="dv">3</span>, <span class="dt">Str</span><span class="op">=&lt;</span><span class="dt">S</span>,<span class="dv">1</span><span class="op">*</span><span class="dt">U</span><span class="op">&gt;&lt;</span><span class="dt">S</span>,<span class="dt">U</span><span class="op">&gt;&lt;</span><span class="dt">L</span>,<span class="dt">U</span><span class="op">&gt;</span>]</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>Main.main_<span class="op">$</span>s<span class="op">$</span>wgo</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> \ (<span class="ot">xs ::</span> [<span class="dt">Int</span>])</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>      (<span class="ot">count ::</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>      (<span class="fu">sum</span><span class="ot"> ::</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span>) <span class="ot">-&gt;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> xs <span class="kw">of</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        [] <span class="ot">-&gt;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>          <span class="kw">case</span> count <span class="kw">of</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            <span class="dv">0</span><span class="op">#</span> <span class="ot">-&gt;</span> lvl2_r4lk <span class="co">-- error &quot;...&quot;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>            _ <span class="ot">-&gt;</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>              (GHC.IO.Handle.Text.hPutStr2</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>                 GHC.IO.Handle.FD.stdout</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>                 (<span class="kw">case</span> <span class="op">GHC.Prim./##</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>                         (GHC.Prim.int2Double<span class="op">#</span> <span class="fu">sum</span>) (GHC.Prim.int2Double<span class="op">#</span> wild1_X1r)</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">of</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>                    _ <span class="ot">-&gt;</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>                      <span class="op">GHC.Float.$</span>w<span class="op">$</span>sshowSignedFloat</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>                        <span class="op">GHC.Float.$</span>fShowDouble2</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>                        GHC.Float.minExpt</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>                        wild4_a3Qb</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>                        (<span class="dt">GHC.Types</span><span class="op">.</span>[] <span class="op">@</span> <span class="dt">Char</span>))</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>                 <span class="dt">GHC.Types.True</span>)</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> x xs <span class="ot">-&gt;</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>          <span class="op">$</span>wgo_r4ll</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>            (<span class="kw">case</span> x <span class="kw">of</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>              <span class="dt">GHC.Types.I</span><span class="op">#</span> y <span class="ot">-&gt;</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>                <span class="dt">GHC.Types.I</span><span class="op">#</span> (<span class="op">GHC.Prim.+#</span> <span class="fu">sum</span> y))</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>            (<span class="op">GHC.Prim.+#</span> count <span class="dv">1</span><span class="op">#</span>)</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>            xs</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>Note that the <code>RunningTotal</code> box is completely gone.
That’s due to GHC optimizing away repeated boxing and unboxing in its <a href="http://www.cs.nott.ac.uk/~pszgmh/wrapper-extended.pdf">worker/wrapper transformation</a>, which is the pass that profits most significantly from strictness information. Without strictness analysis, no unboxing happens, even if you annotate bindings with bangs or activate <code>-XStrict</code>.</p>
<p>All 80MB of remaining allocation (we measured this above) are due to the list of integers.
We can do better by recognizing the fold pattern in <code>go</code> and make use of <code>foldl</code> (that’s right, it even works with the lazy one!), which takes part in list fusion since GHC 7.10:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RunningTotal</span> <span class="ot">=</span> <span class="dt">RunningTotal</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> sum   ::</span> <span class="dt">Int</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> count ::</span> <span class="dt">Int</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="ot">printAverage ::</span> <span class="dt">RunningTotal</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>printAverage (<span class="dt">RunningTotal</span> <span class="op">!</span><span class="fu">sum</span> count)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> count <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Need at least one value!&quot;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">print</span> (<span class="fu">fromIntegral</span> <span class="fu">sum</span> <span class="op">/</span> <span class="fu">fromIntegral</span><span class="ot"> count ::</span> <span class="dt">Double</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="ot">printListAverage ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>printListAverage <span class="ot">=</span> printAverage <span class="op">.</span> <span class="fu">foldl</span> f (<span class="dt">RunningTotal</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    f (<span class="dt">RunningTotal</span> <span class="fu">sum</span> count) x <span class="ot">=</span> <span class="dt">RunningTotal</span> (<span class="fu">sum</span> <span class="op">+</span> x) (count <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> printListAverage [<span class="dv">1</span><span class="op">..</span><span class="dv">1000000</span>]</span></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack <span class="at">--resolver</span><span class="op">=</span>nightly-2017-12-01 ghc <span class="at">--</span> <span class="at">-O2</span> average.hs <span class="kw">&amp;&amp;</span> <span class="ex">./average</span> +RTS <span class="at">-s</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ex">500000.5</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>          <span class="ex">98,784</span> bytes allocated in the heap</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>           <span class="ex">1,752</span> bytes copied during GC</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>          <span class="ex">42,856</span> bytes maximum residency <span class="er">(</span><span class="ex">1</span> sample<span class="er">(</span><span class="ex">s</span><span class="kw">))</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>          <span class="ex">26,776</span> bytes maximum slop</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>               <span class="ex">2</span> MB total memory in use <span class="er">(</span><span class="ex">0</span> MB lost due to fragmentation<span class="kw">)</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="ex">INIT</span>    time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="ex">MUT</span>     time    0.000s  <span class="er">(</span>  <span class="ex">0.002s</span> elapsed<span class="kw">)</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="ex">GC</span>      time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="ex">EXIT</span>    time    0.000s  <span class="er">(</span>  <span class="ex">0.000s</span> elapsed<span class="kw">)</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="ex">Total</span>   time    0.000s  <span class="er">(</span>  <span class="ex">0.003s</span> elapsed<span class="kw">)</span></span></code></pre></div>
<p>That’s only 3ms (from 9ms earlier), and allocations have completely vanished! Let’s look at the Core output:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>Main.main_<span class="op">$</span>s<span class="op">$</span>wgo [<span class="dt">Occ</span><span class="ot">=</span><span class="dt">LoopBreaker</span>]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">RunningTotal</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>[<span class="dt">GblId</span>, <span class="dt">Arity</span><span class="ot">=</span><span class="dv">3</span>, <span class="dt">Caf</span><span class="ot">=</span><span class="dt">NoCafRefs</span>, <span class="dt">Str</span><span class="op">=&lt;</span><span class="dt">L</span>,<span class="dt">U</span><span class="op">&gt;&lt;</span><span class="dt">L</span>,<span class="dt">U</span><span class="op">&gt;&lt;</span><span class="dt">S</span>,<span class="dv">1</span><span class="op">*</span><span class="dt">U</span><span class="op">&gt;</span>m]</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>Main.main_<span class="op">$</span>s<span class="op">$</span>wgo</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> \ (<span class="ot">sc_s4sk ::</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>      (<span class="ot">sc1_s4sj ::</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>      (<span class="ot">sc2_s4si ::</span> <span class="dt">GHC.Prim.Int</span><span class="op">#</span>) <span class="ot">-&gt;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> sc2_s4si <span class="kw">of</span> wild_X1h {</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        __DEFAULT <span class="ot">-&gt;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>          Main.main_<span class="op">$</span>s<span class="op">$</span>wgo</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            (<span class="op">GHC.Prim.+#</span> sc_s4sk <span class="dv">1</span><span class="op">#</span>)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>            (<span class="op">GHC.Prim.+#</span> sc1_s4sj wild_X1h)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>            (<span class="op">GHC.Prim.+#</span> wild_X1h <span class="dv">1</span><span class="op">#</span>);</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="dv">1000000</span><span class="op">#</span> <span class="ot">-&gt;</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Main.RunningTotal</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>            (<span class="dt">GHC.Types.I</span><span class="op">#</span> (<span class="op">GHC.Prim.+#</span> sc1_s4sj <span class="dv">1000000</span><span class="op">#</span>))</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>            (<span class="dt">GHC.Types.I</span><span class="op">#</span> (<span class="op">GHC.Prim.+#</span> sc_s4sk <span class="dv">1</span><span class="op">#</span>))</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>      }</span></code></pre></div>
<p>Amazing! No boxing happening at all.
That should be enough to reach C level performance, given a good compiler backend.
The takeaway is that using <code>foldl</code> is great as long as list fusion kicks in, but better err on the safe side and use the strict <code>foldl'</code> when we expect strictness anyway.</p>
<h2 id="summary">Summary</h2>
<p>This post tried to demonstrate how to debug strictness in the face of compiler optimizations to achieve minimal time and space footprints.
For that, we re-enacted how the compiler analyzes strictness properties of functions, to eventually pin down the subtle culprit in <code>printAverage</code>.
This kind of debugging is only possible through having a rough idea of strictness analysis and reading relevant GHC Core fragments and as such only makes sense with optimizations activated.</p>
<p>Of course, library writers have good reason to sprinkle bang patterns more liberally:
They need to guarantee that the maximum residency stays as low as possible for snappy <code>-O0</code> performance.
That’s what experimentally placing bang patterns at accumulators is good for:
Keeping the maximum residency at a minimum, so that time spent on GC is as low as possible.
It’s <em>not</em> good for teaching GHC what to unbox (e.g. reducing total allocations by more than a constant factor), as that doesn’t happen anyway at <code>-O0</code>.
And as soon as optimizations kick in, strictness analysis is mostly smart enough to figure things out by itself.</p>
<p>The next part of this series will implement a strictness analysis with the help of <a href="https://github.com/sgraf812/datafix"><code>datafix</code></a>, a new library of mine for writing static analyses.</p>
<p>Finally, some links for further reading:</p>
<ul>
<li><a href="http://blog.ezyang.com/2011/05/anatomy-of-a-thunk-leak/">Edward Yang: Anatomy of a thunk leak (2011)</a></li>
<li><a href="https://donsbot.wordpress.com/2008/05/06/write-haskell-as-fast-as-c-exploiting-strictness-laziness-and-recursion/">Don Stewart: Write Haskell as fast as C (2008)</a></li>
<li><a href="https://wiki.haskell.org/Performance/Strictness#Strictness_analysis">Haskell Wiki on Strictness (Analysis)</a></li>
</ul>
<p><b id="f1">1</b> That’s actually a bit simplified, as the real signature is <code>&lt;B,_&gt;&lt;B,_&gt;</code>, where <code>B</code> denotes a <em>hyperstrict</em> demand as explained on <a href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Demand">the wiki page</a>. <a href="#a1">↩︎</a></p>]]></summary>
</entry>
<entry>
    <title>Hakyll Code Highlighting Themes</title>
    <link href="https://sgraf812.github.io//blog/2017-12-03-hakyll-highlighting-themes.html" />
    <id>https://sgraf812.github.io//blog/2017-12-03-hakyll-highlighting-themes.html</id>
    <published>2017-12-03T00:00:00Z</published>
    <updated>2017-12-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>As <a href="https://jaspervdj.be/hakyll/tutorials/faq.html#does-hakyll-support-syntax-highlighting"><code>Hakyll</code>s FAQ</a> points out, in order to have source code highlighting for your blog, you need appropriate CSS markup.
It would be convenient if one could choose from the wealth of themes out there, but the existing pygments styles don’t seem to work any longer.</p>
<!--more-->
<p>That’s probably because <a href="https://hackage.haskell.org/package/pandoc"><code>pandoc</code></a> has since deprecated <a href="https://hackage.haskell.org/package/highlighting-kate"><code>highlighting-kate</code></a> in favor of <a href="https://hackage.haskell.org/package/skylighting"><code>skylighting</code></a>, which adopts a different CSS naming convention, thus invalidating all prior CSS themes.</p>
<p><code>skylighting</code> has a console app for highlighting code, but it doesn’t seem to be able to just dump CSS files for its rich style database.
Fortunately, we can just pick from one of the <a href="https://hackage.haskell.org/package/skylighting-0.4.4.1/docs/Skylighting-Styles.html">pre-defined styles</a> and generate the CSS with a GHCi two-liner:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>$ stack --resolver=nightly-2017-12-01 --install-ghc install skylighting</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>$ stack --resolver=nightly-2017-12-01 ghci</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Prelude<span class="op">&gt;</span> import Skylighting</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>Prelude Skylighting<span class="op">&gt;</span> writeFile &quot;zenburn<span class="fu">.css</span>&quot; $ styleToCss zenburn</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Prelude Skylighting<span class="op">&gt;</span> ^D</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>$ cat zenburn<span class="fu">.css</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>div<span class="fu">.sourceLine</span><span class="op">,</span> a<span class="fu">.sourceLine</span> { <span class="kw">display</span><span class="ch">:</span> <span class="dv">inline-block</span><span class="op">;</span> <span class="kw">min-height</span><span class="ch">:</span> <span class="dv">1.25</span><span class="dt">em</span><span class="op">;</span> }</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>a<span class="fu">.sourceLine</span> { <span class="kw">pointer-events</span><span class="ch">:</span> <span class="dv">none</span><span class="op">;</span> <span class="kw">color</span><span class="ch">:</span> <span class="bu">inherit</span><span class="op">;</span> <span class="kw">text-decoration</span><span class="ch">:</span> <span class="bu">inherit</span><span class="op">;</span> }</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="fu">.sourceCode</span> { <span class="kw">overflow</span><span class="ch">:</span> <span class="dv">visible</span><span class="op">;</span> }</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>code<span class="fu">.sourceCode</span> { <span class="kw">white-space</span><span class="ch">:</span> <span class="dv">pre</span><span class="op">;</span> }</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="im">@media</span> <span class="an">print</span> {</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>code<span class="fu">.sourceCode</span> { <span class="kw">white-space</span><span class="ch">:</span> <span class="dv">pre-wrap</span><span class="op">;</span> }</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>div<span class="fu">.sourceLine</span><span class="op">,</span> a<span class="fu">.sourceLine</span> { <span class="kw">text-indent</span><span class="ch">:</span> <span class="dv">-1</span><span class="dt">em</span><span class="op">;</span> <span class="kw">padding-left</span><span class="ch">:</span> <span class="dv">1</span><span class="dt">em</span><span class="op">;</span> }</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>pre<span class="fu">.numberSource</span> div<span class="fu">.sourceLine</span><span class="op">,</span> <span class="fu">.numberSource</span> a<span class="fu">.sourceLine</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  { <span class="kw">position</span><span class="ch">:</span> <span class="dv">relative</span><span class="op">;</span> }</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>...</span></code></pre></div>
<p>With a little more effort, you could probably access <code>skylighting</code>s whole style database, but I’m currently satisfied with the style I installed.</p>]]></summary>
</entry>

</feed>
